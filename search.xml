<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>说说失效处理办法</title>
      <link href="posts/56722.html"/>
      <url>posts/56722.html</url>
      
        <content type="html"><![CDATA[<h1 id="说说失效恢复步骤"><a href="#说说失效恢复步骤" class="headerlink" title="说说失效恢复步骤"></a>说说失效恢复步骤</h1><ol><li>打开LeanCloud国际版官网:[<a href="https://console.leancloud.app/]%EF%BC%9B">https://console.leancloud.app/]；</a></li><li>账号密码登录；</li><li>检查原因及操作步骤<ol><li>存储器服务数据已归档（30天无api请求，应用归档后，存储以及依赖存储的服务不可用）</li><li>重新 激活</li></ol></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>graph</title>
      <link href="posts/graph.html"/>
      <url>posts/graph.html</url>
      
        <content type="html"><![CDATA[<h1 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h1><h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><pre class=" language-markdown"><code class="language-markdown">ADT Graph{<span class="token code keyword">    数据对象V:    V是具有相同特性的数据元素的集合，称为顶点集。</span><span class="token code keyword">    数据关系R:    R={VR}</span><span class="token code keyword">                VR = {&lt;v,w>|v,w∈V且P(v,w),&lt;v,w>表示从v到w的弧，谓语P(v,w)定义了弧&lt;v,w>的意义和信息}</span><span class="token code keyword">    基本操作:</span><span class="token code keyword">        Adjacent(G,x,y)：判断图G是否存在边或（x，y）</span><span class="token code keyword">        Neighbors(G,x)：列出图G中与结点x邻接的边</span><span class="token code keyword">        InsertVertex(G,x)：在图G中插入顶点x</span><span class="token code keyword">        DeleteVertex(G,x)：从图G中删除顶点x</span><span class="token code keyword">        AddEdge(G,x,y)：若无向边（x，y）或有向边&lt;x,y>不存在，则向图G中添加该边</span><span class="token code keyword">        RemoveEdge(G,x,y)：若无向边（x，y）或有向边&lt;x,y>存在，则从图G中删除该边</span><span class="token code keyword">        FirstNeighbor(G,x)：求图G中顶点x的第一个邻接点，若有则返回顶点号。若x没有邻接点或图中不存在x，则返回-1</span><span class="token code keyword">        NextNeighbor(G,x,y)：假设图G中顶点y是顶点x的一个邻接点，返回除y之外顶点x的下一个邻接点的顶点号，若y是x的最后一个邻接点，则返回-1</span><span class="token code keyword">        Get_edge_value(G,x,y)：获取图G中边(x，y)或对应的权值</span><span class="token code keyword">        Set_edge_value(G,x,y,v)：设置图G中边（x，y）或对应的权值为v</span>}ADT Graph</code></pre><h1 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h1><h2 id="邻接矩阵⭐"><a href="#邻接矩阵⭐" class="headerlink" title="邻接矩阵⭐"></a>邻接矩阵⭐</h2><h3 id="结构描述"><a href="#结构描述" class="headerlink" title="结构描述"></a>结构描述</h3><pre class=" language-c++"><code class="language-c++">#define MaxVertexNum 100        //顶点数目的最大值typedef struct{    char    Vex[MaxVertexNSum];    //顶点表    int        Edge[MaxVertexNum][MaxVertexNum];    //邻接矩阵，边表    int     vexnum,arcnum;        //图的当前顶点数和边数/弧数}MGraph;</code></pre><p>结点数为n的图G=（V，E）的邻接矩阵A是nxn的。将G的顶点编号为$v_1,v_2…,v_n$则1，则</p><p>$A[i][j]=\begin{cases}1,&amp;若(v_i,v_j)或&lt;v_i,v_j&gt;是E(G)中的边\0,&amp;若(v_i,v_j)或&lt;v_i,v_j&gt;不是E(G)中的边\end{cases}$</p><p>其中第i个结点的度=第i行（或第i例）的非零元素个数</p><p>第i个结点的出度=第i行的非零元素个数<br>第i个结点的入度=第i列的非零元素个数<br>第i个结点的度=第i行、第i例的非零元素个数之和</p><p>邻接矩阵法<strong>求顶点的度/出度/入度</strong>的时间复杂度为O(|V|)<br>空间复杂度：$O(|V|^2)$——只和顶点数相关，和实际的边数无关<br>适合用于存储稠密图<br>无向图的邻接矩阵是<strong>对称矩阵</strong>，可以压缩存储（只存储上三角区/下三角区）</p><h2 id="邻接表——稀疏图节省空间⭐"><a href="#邻接表——稀疏图节省空间⭐" class="headerlink" title="邻接表——稀疏图节省空间⭐"></a>邻接表——稀疏图节省空间⭐</h2><h3 id="结构描述-1"><a href="#结构描述-1" class="headerlink" title="结构描述"></a>结构描述</h3><pre class=" language-c++"><code class="language-c++">//“边/弧”typedef struct ArcNode{    int adjvex;        //边/弧指向哪个结点    struct ArcNode*next;    //指向下一条弧的指针    //InfoType info;    //边权值}ArcNode;//“顶点”typedef struct VNodes{    VertexType data;    //顶点信息    ArcNode*first;        //第一条边/弧}Node,AdjList[MaxVertexNum];//用邻接表存储的图typedef struct{    AdjList vertices;    int vexnum，arcnum;}ALGraph;</code></pre><p>无向图：边结点的数量是2|E|，整体空间复杂度为0（|V|+2|E|）<br>有向图：边结点的数量是|E|，整体空间复杂度为O（|V|+|E|）</p><p>思考：如何求顶点的度、入度、出度？如何找到与一个顶点相连的边/弧？</p><p><img src="https://api2.mubu.com/v3/document_image/4cf99bc7-9aff-4b05-90a8-f4dec8598683-3773567.jpg" alt="image"></p><h1 id="深度优先搜索遍历图"><a href="#深度优先搜索遍历图" class="headerlink" title="深度优先搜索遍历图"></a>深度优先搜索遍历图</h1><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>​    图的深度优先搜索遍历（DFS）类似于二叉树的先序遍历。</p><p>​    它的基本思想是：首先访问出发点v，并将其标记为已访问过；然后选取与v邻接的未被访问的任意一个顶点w，并访问它；再选取与w邻接的未被访问的任一顶点并访问，以此重复进行。</p><p>​    当一个顶点所有的邻接顶点都被访问过时，则依次退回到最近被访问过的顶点，若该顶点还有其他邻接顶点未被访问，则从这些未被访问的顶点中取一个并重复上述访问过程，直至图中所有顶点都被访问过为止。</p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><pre class=" language-c++"><code class="language-c++">void DFS(graph *g){    int i;    for(i=0;i<g->n;i++)        visid[i]=0;    for(i=0;i<g->n;i++)        if(!visid[i])            DFSM(g,i);}void DFSM(graph *g,int i){    int j;    printf("深度优先遍历节点：%c\n",g->vexs[i]);    visid[i]=1;    for(j=0;j<g->n;j++)        if((g->edges[i][j]!=0)&&!visid[j])            DFSM(g,j);}</code></pre><h3 id="邻接表遍历"><a href="#邻接表遍历" class="headerlink" title="邻接表遍历"></a>邻接表遍历</h3><pre class=" language-c++"><code class="language-c++">//深度优先搜索遍历图void DFS(ALGraph g){    for(int i = 0;i<g->vexnum;i++){        if(g->vertices[i].firstarc&&!visit[i])            DFSM(g,i);    }}//深度优先搜索遍历图void DFSM(ALGraph g,int i){    ArcNode *temp ;    visit[i] = 1;    //visited(g);    temp = g->vertices[i].firstarc;    while(!temp){        if(!visit[temp->adjvex]){            DFSM(g,temp->adjvex);        }        temp = temp->nextarc;    }}</code></pre><h2 id="广度优先搜索遍历图"><a href="#广度优先搜索遍历图" class="headerlink" title="广度优先搜索遍历图"></a>广度优先搜索遍历图</h2><h2 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h2><p>1）任取图中一个顶点访问，入队，并将这个顶点标记为已访问；<br>2）当队列不空时循环执行：出队，依次检查出队顶点的所有邻接顶点，访问没有被访问过的邻接顶点并将其入队；<br>3）当队列为空时跳出循环，广度优先搜索即完成。</p><h2 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h2><h3 id="邻接矩阵-1"><a href="#邻接矩阵-1" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><pre class=" language-c++"><code class="language-c++">void BFS(graph *g){    int i;    for(i=0;i<g->n;i++)        visit[i]=0;    for(i=0;i<g->n;i++)        if(!visit[i])            BFSM(g,i);}void BFSM(graph *g,int i){    int que[MAXSIZE];    int front = 0,rear = 0;    int j;    rear = (rear+1)%MAXSIZE;    que[rear] = i;    while(rear != front){        front = (front+1)%MAXSIZE;        j = que[front];        printf("广度优先遍历节点：%c\n",g->vexs[j]);        visit[j]=1;        for(int m=0;m<g->n;m++)                if((g->edges[j][m]!=0)&&!visit[m]){                    rear = (rear+1)%MAXSIZE;                    que[rear] = m;                    }    }    }</code></pre><h3 id="邻接表遍历-1"><a href="#邻接表遍历-1" class="headerlink" title="邻接表遍历"></a>邻接表遍历</h3><pre class=" language-c++"><code class="language-c++">//广度优先搜索遍历图void BFSM(ALGraph g,int i,queue *&q){    ArcNode *temp ;    int j;    visit[i] = 1;//visited(g,i);    q->rear = (q->rear+1)%maxsize;    q->data[q->rear] = i;    while((q->front+1)%maxsize != q->rear){        j = q->data[q->front];        q->front=(q->rear+1)%maxsize;        temp = g->vertices[j].firstarc;        while(!temp){            if(!visit[temp->adjvex]){                visit[temp->adjvex] = 1;//visited(g,i);                q->rear = (q->rear+1)%maxsize;                q->data[q->rear] = temp->adjvex;            }            temp = temp->nextarc;        }    }}</code></pre><h1 id="最小生成树（最小代价树）—MST"><a href="#最小生成树（最小代价树）—MST" class="headerlink" title="最小生成树（最小代价树）—MST"></a>最小生成树（最小代价树）—MST</h1><h2 id="Prim——边多点少——根据顶点来求——时间复杂-O-V-2"><a href="#Prim——边多点少——根据顶点来求——时间复杂-O-V-2" class="headerlink" title="Prim——边多点少——根据顶点来求——时间复杂$O(V^2)$"></a>Prim——边多点少——根据顶点来求——时间复杂$O(V^2)$</h2><p>从某一个顶点开始构建生成树；每次将代价最小的新顶点纳入生成树，直到所有顶点都纳入为止。</p><p>适合用于边稠密图</p><h3 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h3><p>从树中某一个顶点v_0开始，构造生成树的算法执行过程如下：</p><ul><li>1）将v_0_到其他顶点的所有边当作候选边;</li><li>2）重复以下步骤n-1次，使得其他n-1个顶点被并入到生成树中。<ul><li>①从候选边中挑选出权值最小的边输出，并将与该边另一端相接的顶点v并入生成树中；</li><li>②考查所有剩余顶点$v_i$,如果$（v，v_i）$的权值比lowcost[v]小，则用$（v，v_i）$的权值更新lowcost[v_i].</li></ul></li></ul><h3 id="算法的实现"><a href="#算法的实现" class="headerlink" title="算法的实现"></a>算法的实现</h3><pre class=" language-c++"><code class="language-c++">void Prim(MGraph g,int v_0){    int vest[maxsize],lowcost[maxsize];    int min,i,j,k,v;    for(i=0;i<g->n;i++){        vest[i]=0;        lowcost[i]=g->edge[v_0][i];    }    vest[v_0] = 1;    for(i=0;i<g->n-1;i++){        min = MAX;        for(j=0;j<g->n;j++){            if(!vest[j]&&min>lowcost[j]){                min = lowcost[j];                k = j;            }        }        vest[k]=1;          v=k;        for(i=0;i<g->n;i++){            if(vest[i]==0&&lowcost[i]>g->edge[v][i])            lowcost[i]=g->edge[v][i];        }    }}</code></pre><h2 id="Kruskal——边少点多——根据最小边来求——时间复杂-O-E-log-E"><a href="#Kruskal——边少点多——根据最小边来求——时间复杂-O-E-log-E" class="headerlink" title="Kruskal——边少点多——根据最小边来求——时间复杂$O(E\log(E))$"></a>Kruskal——边少点多——根据最小边来求——时间复杂$O(E\log(E))$</h2><p>每次选择一条权值最小的边，使这条边的两头连通（原本已经连通的就不选）直到所有结点都连通</p><p>适合用于边稀疏图</p><h1 id="单源最短路径"><a href="#单源最短路径" class="headerlink" title="单源最短路径"></a>单源最短路径</h1><h2 id="BFS算法（无权图）"><a href="#BFS算法（无权图）" class="headerlink" title="BFS算法（无权图）"></a>BFS算法（无权图）</h2><p>​    BFS算法求单源最短路径只适用于无权图，或所有边的权值都相同的图</p><h2 id="Dijkstra-算法（带权图、无权图）"><a href="#Dijkstra-算法（带权图、无权图）" class="headerlink" title="Dijkstra 算法（带权图、无权图）"></a>Dijkstra 算法（带权图、无权图）</h2><h3 id="算法思想-3"><a href="#算法思想-3" class="headerlink" title="算法思想"></a>算法思想</h3><p>1）从当前dist[]数组中选出最小值，假设为dist[v_u]，将set[v_u]设置为1，表示当前新并入的顶点为V_u<br>2）循环扫描图中顶点，对每个顶点进行以下检测：<br>        假设当前顶点为v_j检测v_j是否已经被并入S中，即看是否set[v_j]=1。如果set[v_j]=1，则什么都不做；如果set[v_j]=0，则比较dist[v_j]和dist[v_u]+w的大小，其中w为边&lt;v_u，v_j&gt;的权值。这个比较就是要看v_0经过旧的最短路径到达v_j和v_0经过含有V_u的新的最短路径到达v_j哪个更短，如果 dist[v_j]&gt;dist[v_u]+w，则用新的路径长度来更新旧的，并把顶点v_u加入路径中，且作为路径上v_j之前的那个顶点，否则什么都不做。<br>3）对1）和2）循环执行n-l次（n为图中顶点个数），即可得到v_0到其余所有顶点的最短路径。</p><h3 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h3><pre class=" language-c++"><code class="language-c++">void Dijkstra(MGraph g,int v,int dist[],int path[]){    //初始化    int i,j,min,u;    int set[maxsize];    for(i = 0;i<g.n;i++){        dist[i] = g.Edge[v][i];        set[i] = 0;        if(g.Edge[v][i]!=max)    //max已定义，表示一个很大的数            path[i] = v;        else            path[i] = -1;    }    set[v] = 1;    path[v] = -1;    for(i = 0;i<g.n-1;i++){        min = max;                for(j = 0;j<g.n;j++){            if(set[j]==0&&min>dist[j]){                min = dist[j];                 u = j;            }        }        set[u] = 1;        for(j = 0;j<g.n;j++){            if(set[j]==0&&dist[j]>g.Edge[u][j]+dist[u])                dist[j] = g.Edge[u][j]+dist[u])                path[j] = u;        }    }}</code></pre><h1 id="各顶点间的最短路径"><a href="#各顶点间的最短路径" class="headerlink" title="各顶点间的最短路径"></a>各顶点间的最短路径</h1><h2 id="Floyd-算法（带权图、无权图）"><a href="#Floyd-算法（带权图、无权图）" class="headerlink" title="Floyd 算法（带权图、无权图）"></a>Floyd 算法（带权图、无权图）</h2><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>1）设置两个矩阵A和Path，初始时将图的<strong>邻接矩阵</strong>赋值给A，将矩阵Path中元素全部设置为-1。</p><p>2）以顶点k为中间顶点，k取0~n-1（n为图中顶点个数），对图中所有顶点对&lt;i,j&gt;进行如下检测与修改：<br>如果A[i] [j]&gt;A[i] [k]+A[k] [j]，则将A[i] [j]]改为A[i] [k]+A[k] [j]的值，将Path[i] [j]改为k，否则什么都不做。</p><h3 id="算法实现-3"><a href="#算法实现-3" class="headerlink" title="算法实现"></a>算法实现</h3><pre class=" language-c++"><code class="language-c++">void CoutPath(int path[][max],int A[][max],int i,int j){    if(A[i][j]==INF)        return;    else        if(path[i][j]==-1)            cout<<i<<"->"<<j;        else{            int k = path[i][j];            CoutPath(path,A,i,k);            CoutPath(path,A,k,j);        }}void Floyd(MGraph g,int Path[][max],int A[][max]){    int i,j,k;    for(i = 0;i < g.n;i++){        for(j = 0;j < g.n;j++){            Path[i][j] = -1;             A[i][j] = g.Edges[i][j];                    }    }    for(k = 0;k < g.n;k++)        for(i = 0;i < g.n;i++)            for(j = 0;j < g.n;j++)                if(A[i][j]>A[i][k]+A[k][j]){                    A[i][j] = A[i][k]+A[k][j];                    Path[i][j] = k;                }}</code></pre><h1 id="拓扑排序——AOV网——有向无环图顶点的排序——判断图中是否有环"><a href="#拓扑排序——AOV网——有向无环图顶点的排序——判断图中是否有环" class="headerlink" title="拓扑排序——AOV网——有向无环图顶点的排序——判断图中是否有环"></a>拓扑排序——AOV网——有向无环图顶点的排序——判断图中是否有环</h1><h2 id="算法思想-4"><a href="#算法思想-4" class="headerlink" title="算法思想"></a>算法思想</h2><ul><li>①从AOV网中选择一个没有前驱（入度为0）的顶点并输出。</li><li>②从网中删除该顶点和所有以它为起点的有向边。</li><li>③重复①和②直到当前的AOV网为空或当前网中不存在无前驱的顶点为止。</li></ul><h2 id="算法实现-4"><a href="#算法实现-4" class="headerlink" title="算法实现"></a>算法实现</h2><pre class=" language-c++"><code class="language-c++">typedef struct ArcNode{    int adjvex;    struct ArcNode *next;}ArcNode;typedef struct{    char data;    int count;//记录该顶点的入度    ArcNode *firstarc;}VNode;typedef struct{    VNode vertices[maxsize];    int n,e;}AGraph;int TopSort(AGraph *g){    int Stack[maxsize];    int top = -1,n=0;    ArcNode p;    for(int i = 0;i<g->n;i++){        if(g->vertices[i].count == 0)            Stack[++top] = i;    }    while(top != -1){        int i = Stack[top--];        cout<<i<<" ";        n++;        p = g->vertices[i].firstarc;        while(p){            --(g->vertices[p->adjvex].count);            if(g->vertices[p->adjvex].count == 0)                Stack[++top] = p->adjvex            p=p->next;        }    }    if(n == g->n)        return 1;    else        return 0;}</code></pre><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>每个顶点都需要入栈一次，n个顶点n次，入度减一的操作，每条边都会执行e条边执行e次</p><p>时间辅助度为：O(|V|+|E|)</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> data_structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Exercise-questions-stackAndqueue</title>
      <link href="posts/exercise-questions-stackandqueue.html"/>
      <url>posts/exercise-questions-stackandqueue.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> data_structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Exercise-questions-list</title>
      <link href="posts/exercise-questions-list.html"/>
      <url>posts/exercise-questions-list.html</url>
      
        <content type="html"><![CDATA[<p><strong>0. 设顺序表用数组A[]表示，表中元素存储在数组下标0~m+n-1的范围内，前m个元素递增有序，后n个元素也递增有序，设计一个算法，使得整个顺序表有序。</strong></p><p>（1）给出算法的基本设计思想。<br>（2）根据设计思想，采用C或C+语言描述算法，并在关键之处给出注释。<br>（3）说明你所设计的算法的时间复杂度和空间复杂度。</p><p>1.解<br>（1）算法的基本设计思想<br>        将数组A[]中的m+n个元素（假设元素为int型）看成两个顺序表：表L和表R。将数组当前状态看作起始状态，即此时表L由A[]中前m个元素构成，表R由A[]中后n个元素构成，要使A[]中m+n个元素整体有序，只需将表R中的元素逐个插入表L中的合适位置即可。<br>        插入过程：取表R中的第一个元素A[m]存入辅助变量temp中，让temp逐个与A[m-1],…,A[0]<br>进行比较，当temp&lt;A[j]（0≤j≤m-1）时，将A[j]后移一位，否则将temp存入A[j+1]中。重复上述过程，继续插入A[m+1],A[m+2],…,A[m+n-1]，最终A[]中元素整体有序。</p><p>(2)算法描述</p><pre class=" language-c++"><code class="language-c++">void insertElem(int A[]，int m，int n){    int i，j;    int temp;    //辅助变量，用来暂存待插入元素    for(i=m;i<m+n;++i){//将A[m,…,m+n-1]插入到A[0,…,m-1]中        temp=A[i];        for(j=i-1;j>=0&&temp < A[j];--j)            A[j+1]=A[j];//元素后移，以便腾出一个位置插入temp        A[j+1]=temp；//插入temp，由于for循环后j多前移了一位，因此在j+1处插入    }}</code></pre><p>(3)算法的时间和空间复杂度<br>        1）本题的规模由m和n共同决定。取最内层循环中A[j+1]=A[j]；这一句作为基本操作，其执行次数在最坏的情况下为R中的每个元素都小于L中的所有元素；又因R中元素递增有序，所以对于每个R中的元素，要将其插入正确位置都必须进行m次移动，R中共有n个元素，因此有：f(m,n)=mn</p><p>由此可见，本算法的时间复杂度为O(mn)。<br>        2）算法所需额外存储空间与数据规模m和n无关，变化属于常量级，因此空间复杂度为O(1)。</p><p><strong>1.设计一个递归算法，删除不带头结点的单链表工中所有值为x的结点。</strong></p><p>解答：<br>设f(L,x)的功能是删除以L为首结点指针的单链表中所有值等于x的结点，显然有f(L-&gt;next,x)的功能是删除以L-&gt;next为首结点指针的单链表中所有值等于x的结点。由此，可以推出递归模型如下。<br>        终止条件:    f(L,x)≡不做任何事情;                            若L为空表<br>        递归主体:    f(L,x)≡删除*L结点；f(L-&gt;next,x);        若L-&gt;data==x<br>                            f(L,x)≡f(L-&gt;next,x);                                其他情况</p><p>本题代码如下：</p><pre class=" language-c++"><code class="language-c++">void Del_X_3(Linklist &L，ElemType x){//递归实现在单链表L中删除值为x的结点    LNode = *p;            //p指向待删除的结点    if(L==NULL)            //递归出口        return;    if(L->data==x){        //若L所指结点的值为x         p=L;            //删除*L，并让L指向下一结点        L=L->next;        free(p);        Del_X_3(L,x);    //递归调用    }    else        Del_X_3(L->next,x);//递归调用}</code></pre><p>算法需要借助一个递归工作栈，深度为O（n），时间复杂度为O（n）。有读者认为直接去掉P结点会造成断链，实际上因为L为引用，是直接对原链表进行操作的，因此不会断链。</p><pre class=" language-c++"><code class="language-c++">void deleteElement(LNode *pre,LinkList &L,int x){    if(!L)return;    deleteElemt(L,L->next,x);    if(L->elem==x){        LNode *temp = L;        if(pre){            pre->next = L->next;            }else{            L=L->next;        }        free(temp);    }}</code></pre><p><strong>2.在带头结点的单链表L中，删除所有值为x的结点，并释放其空间，假设值为x的结点不唯一，试编写算法以实现上述操作。</strong></p><p>(1)算法的基本设计思想</p><ol><li>设置一指针指P向当前单链表的头结点（即要处理结点的前驱结点），用该指针控制循环遍历</li><li>如果P-&gt;next != NULL，执行3；否则执行6</li><li>判断P-&gt;data与x是否相等，若相等删除P所指后续结点,释放该结点所占空间</li><li>p后移</li><li>重复234步</li><li>程序结束</li></ol><p>(2)算法描述</p><pre class=" language-c++"><code class="language-c++">void deleteElement(LinkList &L,ElemType x){    LNode *p = L,*temp;                    //P指向需要对比结点的前驱    while(p->next){                    //如果当前循环没有后继结点就结束循环        if(p->next->data == x){        //判断当前结点的值是否与x相等            temp = p->next;    //用一个指针指向要释放的结点            p->next = temp->next;    //遍历指针后移            free(temp);                //释放空间        }        else{            p = p->next;        }    }}</code></pre><p>(3)算法的时间和空间复杂度</p><p>​    算法主体为if循环的内容，时间复杂度只与链表长度n有关所以时间复杂度为：O(n)</p><p>​    算法所需额外存储空间与数据规模n无关，变化属于常量级，因此空间复杂度为：O(1)</p><p><strong>3.设L为带头结点的单链表，编写算法实现从尾到头反向输出每个结点的值。</strong></p><p>(1)算法的基本设计思想</p><ul><li>设计一个递归的算法，先递归后输出该值</li><li>递归结束条件: L==NULL</li><li>递归主体：printEndToHead(L-&gt;next);cout&lt;&lt; L-&gt;data;</li></ul><p>(2)算法描述</p><pre class=" language-c++"><code class="language-c++">void printEndToHead(LinkList L){    if(!L)return;    printEndToHead(L->next);    cout<< L->data;}</code></pre><p>(3)算法的时间和空间复杂度</p><p>​    算法需要借助一个递归工作栈，深度为O(n)，时间复杂度为:    O(n)</p><p>​    算法所需额外存储空间与数据规模n无关，变化属于常量级，因此空间复杂度为：O(1)</p><p><strong>4.试编写在带头结点的单链表L中删除一个最小值结点的高效算法（假设最小值结点是唯一的）。</strong></p><p>(1)算法的基本设计思想</p><ol><li>设置两指针p、q，p用于遍历循环，q用于指向当前最小值的前驱结点（默认开始结点为最小值q指向头结点，p指向开始结点）</li><li>如果p-&gt;next != NULL，执行3；否则执行6</li><li>若q-&gt;next-&gt;data &gt; p-&gt;next-&gt;data，q = p;</li><li>p = p-&gt;next;</li><li>重复234步</li><li>删除值最小的结点</li><li>结束程序</li></ol><p>(2)算法描述</p><pre class=" language-c++"><code class="language-c++">void deleteMin(LinkList &L){    LNode *p = L->next,*q = L;    while(p->next){        if(q->next->data > p->next->data) q = p;        p = p->next;    }    LNode *temp = q->next;    q->next = temp->next;    free(q);}</code></pre><p>(3)算法的时间和空间复杂度</p><p>​        该算法的基本操作为p = p-&gt;next;执行次数f(n) = n,时间复杂度为T(n)=O(n)；</p><p>​        算法所需额外存储空间与数据规模n无关，变化属于常量级，因此空间复杂度为O(1)</p><p><strong>5.试编写算法将带头结点的单链表就地逆置，所谓“就地”是指辅助空间复杂度为O(1).</strong></p><p>(1)算法的基本设计思想</p><ol><li>设置指针p指向开始结点,指针temp指向当前操作结点</li><li>若 p != NULL,执行3，否则执行6</li><li>temp指向p，p = p-&gt;next;</li><li>取temp所指结点以头插法，插入原头结点后</li><li>重复234步</li><li>结束程序</li></ol><p>(2)算法描述</p><pre class=" language-c++"><code class="language-c++">void reverse(LinkList &L){    LNode *p=L->next,*temp=L->next;    L->next = NULL;    while(P){        temp = p;        p = p->next;        temp->next = L->next;        L->next = temp;    }}</code></pre><p>(3)算法的时间和空间复杂度</p><p>​        算法基本操作为while循环里面的四条，执行次数为f(n)=n,时间复杂度为O(n)，算法所需额外存储空间与数据规模n无关，变化属于常量级，因此空间复杂度为O(1)</p><p><strong>6.有一个带头结点的单链表L，设计一个算法使其元素递增有序。</strong></p><p>(1)算法的基本设计思想</p><p>​        设置指针p用于遍历当前无序链表的各个结点，q指针查询当前有序链表的合适的插入位置。<br>每次只需把p所指结点逐一与有序链表的结点比较，找到合适位置插入即可。</p><p>​        插入过程：设置工作指针temp指向p所指的结点，P后移指向下一次需要操作的结点。把temp所指结点与有序链表L中结点对比找到合适的插入位置，temp-&gt;next=q-&gt;next;q-&gt;next=temp;重复循环执行，直至p指针为空。</p><p>(2)算法描述</p><pre class=" language-c++"><code class="language-c++">void sortAdd(LinkList &L){    LNode *p = L->next,*q,*temp;    L->next = NULL;    while(p){        *temp = p;        p = p->next;        q = L;        while(q){            if(q->next){                if(q->next->data > temp->data){                    temp->next = q->next;                    q->next = temp;                    break;                }            }            else{                q->next = temp;                temp->next = NULL;            }            q = q->next;        }    }}</code></pre><p>(3)算法的时间和空间复杂度</p><p>​    把内层循环的q = q-&gt;next;看做基本操作，在最坏的情况下（原链表递减排列）p指针所指的结点每次都会与新递增有序L每个结点对比，并插入到链尾。基本语句执行次数f(n) = $\frac{n(n-1)}{2}$,时间复杂度为$T(n) = O(n^2)$;算法所需的辅助空间与规模n无关，变化属于常量级，故空间复杂度为O(1)</p><p><strong>7.设在一个带表头结点的单链表中所有元素结点的数据值无序，试编写一个函数，删除表中所有介于给定的两个值（作为函数参数给出）之间的元素的元素（若存在）。</strong></p><p>(1)算法的基本设计思想</p><p>设置指针p控制循环遍历指向当前结点的前驱，指针temp指向当前需要操作的结点，每次判断若x &lt; p-&gt;next-&lt;data &lt; y，temp指向该结点，p后移。删除释放temp。</p><p>删除过程：temp = p-&gt;next;p-&gt;next = temp-&gt;next;free(temp);</p><p>(2)算法描述</p><pre class=" language-c++"><code class="language-c++">void deleteElementFromXToY(LinkList &L,int x,int y){    LNode *p = L,*temp;    while(p->next){        if(p->next->data > x && p->next->data < y){            temp = p->next;            p->next = temp->next;            free(temp);        }        p = p->next;    }    }</code></pre><p>(3)算法的时间和空间复杂度</p><p>​        算法的基本操作为if中的插入语句，算法的执行次数f(n) = n,时间复杂度为T(n) = O(n);算法的额外空间占用与规模n无关，变化属于常量级，故空间复杂度为O(1)</p><p><strong>8.给定两个单链表，编写算法找出两个链表的公共结点。</strong></p><p>(1)算法的基本设计思想</p><ol><li>设置两个指针p,q分别指向两个单链表</li><li>循环遍历p，每遍历一个结点就扫描q所指链表检查是否为公共结点：p = q</li><li>如果有公共结点，那么久打印该几点及他后面的所有结点</li><li>如果没有，程序结束</li></ol><p>(2)算法描述</p><pre class=" language-c++"><code class="language-c++">void findCommon(LinkList L1,LinkList L2){    LNode *p,*q;    p = L1->next;    while(p){        q = L2->next;        while(q){            if(q == p){                cout<< q->data<< endl;                p = p->next;            }            q = q->next;        }        if(p)            p = p->next;    }}</code></pre><p>(3)算法的时间和空间复杂度</p><p>​    该算法的基本操作为q = q-&gt;next;，最坏的情况是没有公共结点，每遍历L1的一个结点就必须遍历整个L2，需要执行的次数f(n)=mn,时间复杂度T(n)= O(nm)</p><p>由于算法需要的额外辅助空间与规模n无关，变化属于常量级别，所以空间复杂度为O(1)</p><p>(4)算法的基本设计思想</p><p>​    先要分别遍历两个链表得到它们的长度，并求出两个长度之差。在长的链表上先遍历长度之差个结点之后，再同步遍历两个链表，直到找到相同的结点，或者一直到链表结束。此时，该方法的时间复杂度为O（len1+len2）。</p><p>(5)算法描述</p><pre class=" language-c++"><code class="language-c++">LinkList Search_1st_Common(LinkList L1,LinkList L2){    //本算法实现在线性的时间内找到两个单链表的第一个公共结点    int len1 = Length(L1),len2 = Length(L2);    //计算两个链表的表长    LinkList longList,shortList;                //分别指向表长较长和较短的链表    if(len1 > len2){                            //L1表长较长        longList = L1->next;        shortList = L2->next;        dist = len1-len2;                        //表长之差    }    else{                                        //L2表长较长        longList = L2->next;        shortList = L1->next;        dist = len2-len1；                        //表长之差    }    while(dist--)                                //表长的链表先遍历到第dist个结点，然后同步        longList = longList->next;    while(longList1 = NULL){                    //同步寻找共同结点        if(longList == shortList)                //找到第一个公共结点            return longList;        else{                                    //继续同步寻找            longList = longList->next;            shortList = shortList->next;        }//while        return NULL;    }</code></pre><p>(6)算法的时间和空间复杂度</p><p>​    该算法的基本操作为len1 = Length(L1),len2 = Length(L2);求表长。需要执行的次数f(n)=len1+len2,时间复杂度T(n)= O(len1+len2)</p><p>由于算法需要的额外辅助空间与规模n无关，变化属于常量级别，所以空间复杂度为O(1)</p><p><strong>9.给定一个带表头结点的单链表，设head为头指针，结点结构为（data，next），data为整型元素，next为指针，试写出算法：按递增次序输出单链表中各结点的数据元素，并释放结点所占的存储空间（要求：不允许使用数组作为辅助空间）。</strong></p><p>(1)算法的基本设计思想</p><ol><li><p>设置temp指针作为当前操作结点.设置一个结点作为有序链表的头结点，指针L这向该结点，指针q用于查找合适的插入位置</p></li><li><p>设新链表已有序</p></li><li><p>每次从旧链表中选一个结点采用前插法插入新链表，直到旧链表为空</p></li><li><p>遍历新链表，每遍历一个结点就释放该结点所占用的存储空间</p></li></ol><p>   也可对链表进行遍历，在每次遍历中找出整个链表的最小值元素，输出并释放结点所占空间；再查找次小值元素，输出并释放空间，如此下去，直至链表为空，最后释放头结点所占存储空间。该算法的时间复杂度为$O(n^2)$。</p><p>(2)算法描述</p><pre class=" language-c++"><code class="language-c++">void insertSort(LinkLinst &head){    LNode *temp,*q;    LinkList *L = (LNode *)malloc(sizeof(LNode));    L->next = NULL;    q = L;                \\q指向有序链表，用于控制循环对比插入，指向比较结点的前驱    while(head->next){        temp = head->next;        head->next = temp->next;        while(q){            if(q->next&&q->next->data > temp->data){                temp->next = q->next;                q->next = temp;                break;            }else if(!q->next){                temp->next = q->next;                q->next = temp;                break;            }            q = q->next;        }        head = head->next;    }    while(L->next){        temp = L->next;        L->next = temp->next;        cout<< temp->data;        free(temp);    }}</code></pre><p>(3)算法的时间和空间复杂度</p><p>​    算法的基本操作为:q = q-&gt;next;在最坏的情况下，原链表是递减排列,最后递增输出。执行次数为f(n)=$\frac{n(n-1)}{n}+n$​，时间复杂度为$T(n) =O(n^2)$​</p><p>​    由于算法需要的额外辅助空间与规模n无关，变化属于常量级别，所以空间复杂度为O(1)</p><p><strong>10.将一个带头结点的单链表A分解为两个带头结点的单链表A和B，使得A表中含有原表中序号为奇数的元素，而B表中含有原表中序号为偶数的元素，且保持其相对顺序不变。</strong></p><p>(1)算法的基本设计思想</p><ol><li>设置p,temp,r三个指针，p指向A当前需要操作结点的前驱；temp临时指向需要插入的结点；r指向B的末端节；设置变量i用于判断当前序号的奇偶。</li><li>当p所指的结点的后继不为NULL执行3，否者执行5</li><li>通过i判断当前序号的奇偶，如果为偶，就把该结点取出来连接到B的末尾；如果为奇数p后移一位，执行2</li><li>当所有的偶数序号的结点插入B中记得把末端指针改为NULL</li><li>程序结束</li></ol><p>(2)算法描述</p><pre class=" language-c++"><code class="language-c++">void segmentA(LinkList &A,LinkList &B){    LNode *p,*r,*temp;    int i = 1;    p = A;    r = B;    while(p->next){        if(i%2==0){            temp = p->next;            p->next = temp->next;            r->next = temp;            r = r->next;        }        else{            p = p->next;        }        i++;    }    r->next = NULL;}</code></pre><p>(3)算法的时间和空间复杂度</p><p>算法的基本操作为循环体内的操作p = p-&gt;next;i++;其执行次数f(n)=n,时间复杂度为T(n)=O(n),</p><p>由于算法需要的额外辅助空间与规模n无关，变化属于常量级别，所以空间复杂度为O(1)</p><p><strong>11.设$C=\left{a_1,b_1,a_2,b_2,…,a_n,b_n \right}$​为线性表，采用带头结点的hc单链表存放，设计一个就地算法，将其拆分为两个线性表，使得$A=\left{ a_1,a_2,…,a_n \right}，B=\left{b_n,…,b_2,b_1\right}$​</strong></p><p>(1)算法的基本设计思想</p><ol><li>设置指针A,B分别指向$a_1,b_1$​​，temp指向当前需要操作的结点，用i判断当前是a还是b</li><li>只要B指针所指结点还有后续结点，就执行3，否则执行5</li><li>用temp指向B的后继结点，取出该结点，并插入A所指结点后面</li><li>如果当前i为奇数，A指针后移，执行2</li><li>调整AB指针</li><li>程序结束</li></ol><p>(2)算法描述</p><pre class=" language-c++"><code class="language-c++">void fun(LinkList &hc){    LNode *A,*temp,*b;    LinkList B = (LNode*)malloc(sizeof(LNode));    B->next = NULL;    int i = 1;    A = hc->next;    b = A->next;    while(b->next){        temp = b->next;        b->next = temp->next;        temp->next = A->next;        A->next = temp;        if(i%2=1){            A = A->next;        }        i++;    }    b->next = NULL;    B->next = A->next;    A->next = NULL;}</code></pre><p>(3)算法的时间和空间复杂度</p><p>​    算法的基本操作为循环体中的部分，所以该部分的执行次数f(n) = n,时间复杂度为T(n)=O(n),由于算法需要的额外辅助空间与规模n无关，变化属于常量级别，所以空间复杂度为O(1)</p><p><strong>12.在一个递增有序的线性表中，有数值相同的元素存在。若存储方式为单链表，设计算法去掉数值相同的元素，使表中不再有重复的元素，例如（7，10，10，21，30，42，42，42，51，70）将变为（7，10，21，30，42，51，70）。</strong></p><p>(1)算法的基本设计思想</p><ol><li>设置循环指针r和临时指针temp；</li><li>每次判断r和r的后续结点是否相等，若相等就使用temp删除释放后继结点，若不等r后移</li><li>r后继不等于NULL执行2，r的后继为空，程序结束</li></ol><p>(2)算法描述</p><pre class=" language-c++"><code class="language-c++">void deleteExcessElem(LinkList &L){    LNode *r,*temp;    r = L->next;    while(r->next){        temp = r->next;        if(temp->data == r->data){            r->next = temp->next;            free(temp);        }        r = r->next;    }}void deleteExcessElem2(LinkList &L){    LNode *r,*temp,*q;    r = L->next;    q = r->next;    while(q){        if(q->data == r->data){            q = q->next;        }else{            if(r->next == q){                r = r->next;                q = q->next;                continue;               }            else{                temp = q;                q = q->next;                temp->next = r->next;                r->next = temp;                r = r->next;            }                    }    }}</code></pre><p>(3)算法的时间和空间复杂度</p><p>​    算法的基本操作为循环体中的部分，所以该部分的执行次数f(n) = n,时间复杂度为T(n)=O(n),由于算法需要的额外辅助空间与规模n无关，变化属于常量级别，所以空间复杂度为O(1)</p><p><strong>13.假设有两个按元素值递增次序排列的线性表，均以单链表形式存储。请编写算法将这两个单链表归并为一个按元素值递减次序排列的单链表，并要求利用原来两个单链表的结点存放归并后的单链表。</strong></p><p>(1)算法的基本设计思想</p><ol><li>设置三个指针p，q分别指向这两个链表的开始结点，temp指向当前需要进行插入操作的结点</li><li>如果两个链表当前结点p，q都存在执行3，否则执行5</li><li>比较pq的大小，temp指向当前较小的那个结点，pq中结点值较小的指针后移一位</li><li>把它取出来用头插法的方式插入L，执行2</li><li>判断当前pq是否为空，若不为空还是采用头插法把剩余的结点插入L</li><li>程序结束</li></ol><p>(2)算法描述</p><pre class=" language-c++"><code class="language-c++">void merge(LinkList &L,LinkList &R){    LNode *q,*temp,*p;    p = L->next;    q = R->next;    L->next = NULL;    while(p&&q){        if(q->data <= p->data){            temp = p;            p = p->next;            temp->next = L->next;            L->next = temp;        }else{            temp = q;            q = q->next;            temp->next = L->next;            L->next = temp;        }    }    while(p){        temp = p;        p = p->next;        temp->next = L->next;        L->next = temp;    }    while(q){        temp = q;        q = q->next;        temp->next = L->next;        L->next = temp;    }}</code></pre><p>(3)算法的时间和空间复杂度</p><p>算法的基本操作为第一个循环中的if，else。在最坏的情况下，两个链表每插入一个结点就需要对比一次，那么执行次数f(n)=m+n,算法的时间复杂度为T(n)=O(n+m),由于算法需要的额外辅助空间与规模n无关，变化属于常量级别，所以空间复杂度为O(1)</p><p><strong>14.设A和B是两个单链表（带头结点），其中元素递增有序。设计一个算法从A和B中的公共元素产生单链表C，要求不破坏A、B的结点。</strong></p><p>(1)算法的基本设计思想</p><ol><li>设置指针pq用于控制遍历AB</li><li>当pq都不为空时，执行3，否则执行4</li><li>判断pq的值的大小，值较小指针后移一位；若值相同则申请一个新结点并把该值赋给该结点，把该结点插入C中，pq同时后移一位，执行2</li><li>程序结束</li></ol><p>(2)算法描述</p><pre class=" language-c++"><code class="language-c++">void createNewFromAB(LinkList &A,LinkList &B){    LNode *q,*p;    p = A->next;    q = B->next;    LinkList C = (LNode*)malloc(sizeof(LNode));    if(!C){        cout<< "err"<< endl;        return;    }    C->next = NULL;    while(q&&p){        if(q->data > p->data){            p = p->next;        }        else if(q->data < p->data){            q = q->next;        }        else if(q->data == p->data){            LNode *node = (LNode*)malloc(sizeof(LNode));            if(!node){                cout<< "err"<< endl;                return;            }            node->data = q->next->data;            node->next = C->next;            C->next = node;            p = p->next;            q = q->next;        }    }}</code></pre><p>(3)算法的时间和空间复杂度</p><p>算法的基本操作为while循环中的判断，该操作执行的次数为f(n) =min{m,n},所以算法的时间复杂度为T(n)=O(min{m,n}),由于算法需要的额外辅助空间与规模n无关，变化属于常量级别，所以空间复杂度为O(1)</p><p><strong>15.已知两个链表A和B分别表示两个集合，其元素递增排列。编制函数，求A与B的交集，并存放于A链表中。</strong></p><p>(1)算法的基本设计思想</p><ol><li>设置指针pq分别指向A链表头结点和B链表的开始结点，指针temp用于存储待释放的结点的指针</li><li>当p-&gt;next和q都不为空时，执行3，否则执行4</li><li>判断pq的值的大小，若q较小指针q后移一位；若p较小删除释放该结点，若值相同则pq同时后移一位，执行2</li><li>把p的后继结点的指针域置空</li><li>程序结束</li></ol><p>(2)算法描述</p><pre class=" language-c++"><code class="language-c++">void createNewFromAB(LinkList &A,LinkList &B){    LNode *q,*p,*temp;    p = A;    q = B->next;    while(q&&p->next){        if(q->data > p->next->data){            p = p->next;        }        else if(q->data < p->next->data){            temp = q->next;            q->next = temp->next;            free(temp);        }        else if(q->data == p->next->data){            p = p->next;            q = q->next;            break;        }    }    p->next->next = NULL;}</code></pre><p>(3)算法的时间和空间复杂度</p><p>​    算法的基本操作为while循环中的判断，该操作执行的次数为f(n) =min{m,n},所以算法的时间复杂度为T(n)=O(min{m,n}),由于算法需要的额外辅助空间与规模n无关，变化属于常量级别，所以空间复杂度为O(1)</p><p><strong>16.两个整数序列$A=a_1,a_2,a_3,…,a_m$​​和$B=b_1,b_2,b_3,…,b_n.$​​​已经存入两个单链表中，设计一个算法，判断序列B是否是序列A的连续子序列。</strong></p><p>(1)算法的基本设计思想</p><p>KMP</p><p>(2)算法描述</p><p>(3)算法的时间和空间复杂度</p><p><strong>17.设计一个算法用于判断带头结点的循环双链表是否对称。</strong></p><p>(1)算法的基本设计思想</p><ol><li>设置指针pq分别向前后遍历</li><li>若p!=q&amp;&amp;p-&gt;next!=q执行3，否则执行4</li><li>若p-&gt;data == q-&gt;data，pq后移一位执行2否则结束程序返回false</li><li>结束程序返回true</li></ol><p>(2)算法描述</p><pre class=" language-c++"><code class="language-c++">bool isSymmetry(DLinkList L){    LNode *p,*q;    p = L->prior;    q = L->next;    while(p!=q&&p->next!=q){        if(p->data == q->data){            p = p->prior;               q = q->next;        }        else{            return false;        }    }    return true;}</code></pre><p>(3)算法的时间和空间复杂度</p><p>算法的基本操作为while循环中的判断，该操作执行的次数为f(n) =$\frac n2$,所以算法的时间复杂度为T(n)=O(n),由于算法需要的额外辅助空间与规模n无关，变化属于常量级别，所以空间复杂度为O(1)</p><p><strong>18.有两个循环单链表，链表头指针分别为h1和h2，编写一个函数将链表h2链接到链表h1之后，要求链接后的链表仍保持循环链表形式。</strong></p><p>(1)算法的基本设计思想</p><p>​    设置指针p用于循环遍历h1，q指向h2的开始结点。循环遍历h1找到h1头结点的前驱结点，用p指向该结点，并把q连接到p的结点之后作为p的后继结点，把L2连接点L1之前作为L1的前驱（找到h1的尾指针h2的开始结点，把h1的尾指针链接到h2的开始结点；把h2的头结点链接到h1的头结点）</p><p>(2)算法描述</p><pre class=" language-c++"><code class="language-c++">void combineAWithB(LinkList &h1,LinkList &h2){    LNode *p,*q;    p = h1;    q = h2->next;    while(p->next != h1)        p = p->next;    p->next = q;    h2->next = h1;}</code></pre><p>(3)算法的时间和空间复杂度</p><p>算法的基本操作为p = p-&gt;next;，该操作执行的次数为f(n) =$n$​,所以算法的时间复杂度为T(n)=O(n),由于算法需要的额外辅助空间与规模n无关，变化属于常量级别，所以空间复杂度为O(1)</p><p><strong>19.设有一个带头结点的循环单链表，其结点值均为正整数。设计一个算法，反复找出单链表中结点值最小的结点并输出，然后将该结点从中删除，直到单链表空为止，再删除表头结点。</strong></p><p>(1)算法的基本设计思想</p><ol><li>设置指针p用于循环遍历链表，指针q指向当前最小结点的前驱，temp指向当前需要删除释放的结点</li><li>若链表不为空，执行3，否则执行6</li><li>循环遍历链表，判断当前结点与最小结点的大小，若当前结点更小，则修改最小值前驱结点的指针；若更大，p后移</li><li>直至p-&gt;next == L，p指向该链表最后一个结点，q后继结点为当前链表的最小值输出删除释放该结点，修改p指针指向头结点。</li><li>重复执行234</li><li>删除头结点，程序结束</li></ol><p>(2)算法描述</p><pre class=" language-c++"><code class="language-c++">void findMin(LinkList &L){    LNode *p,*q,*temp;    p = L;    q = NULL;    while(p->next){        if(!q||q->next->data > p->next->data){            q = p;        }        p = p->next;        if(p->next == L){            p = L;            temp = q->next;            q->next = temp->next;            q = NULL;            cout<<  temp->data<<  endl;            free(temp);        }    }    temp = L;    free(L);}</code></pre><p>(3)算法的时间和空间复杂度</p><p>​    算法的基本操作为p = p-&gt;next;最坏情况该循环链表为递减有序的，该操作执行的次数为f(n) =$\frac {n(n+1)}2$​,所以算法的时间复杂度为$T(n)=O(n^2)$​,由于算法需要的额外辅助空间与规模n无关，变化属于常量级别，所以空间复杂度为O(1)</p><p><strong>20.设头指针为L的带有表头结点的非循环双向链表，其每个结点中除有pred（前驱指针）、data（数据）和next（后继指针）域外，还有一个访问频度域freq。在链表被启用前，其值均初始化为零。每当在链表中进行一次Locate（L，x）运算时，令元素值为x的结点中freq域的值增1，并使此链表中结点保持按访问频度非增（递减）的顺序排列，同时最近访问的结点排在频度相同的结点前面，以便使频繁访问的结点总是靠近表头。试编写符合上述要求的Locate（L，x）运算的算法，该运算为函数过程，返回找到结点的地址，类型为指针型。</strong></p><p>(1)算法的基本设计思想</p><p>循环遍历链表，如果该结点的值等于x其freq域的值加1，并把该结点取出来采用头插法的方式插入到L头结点后。</p><p>取值与x相同的结点：temp-pred-&gt;next = temp-&gt;next;temp-&gt;next-&gt;pred = temp-pred;</p><p>头插法：temp-&gt;next = L-&gt;next;temp-&gt;pred = L;L-&gt;next = temp;temp-&gt;next-&gt;pred = temp;</p><p>正确思想：首先在双向链表中查找数据值为x的结点，查到后，将结点从链表上摘下，然后顺着结点的前驱链查找该结点的插入位置（频度递减，且排在同频度的第一个，即向前找到第一个比它的频度大的结点，插入位置为该结点之后），并插入到该位置。</p><p>(2)算法描述</p><pre class=" language-c++"><code class="language-c++">DLNode *Locate(DLinkList &L,int x){    DLNode *p,*temp;    p = L->next;    while(p){        if(p->data == x){            temp = p;            p = p->next;            temp->freq ++;            temp-pred->next = temp->next;            temp->next->pred = temp-pred;            temp->next = L->next;            temp->pred = L;            L->next = temp;            temp->next->pred = temp;        }else{            p = p->next;        }    }}</code></pre><p>(3)算法的时间和空间复杂度</p><p>算法的基本操作为while循环内的部分;最坏情况该链表等于x值的结点在最后，该操作执行的次数为f(n) =$n$​​,所以算法的时间复杂度为$T(n)=O(n)$​​,由于算法需要的额外辅助空间与规模n无关，变化属于常量级别，所以空间复杂度为O(1)</p><p><strong>21.【2009统考真题】已知一个带有表头结点的单链表，结点结构为：【data|link】假设该链表只给出了头指针list。在不改变链表的前提下，肯改计一个尽可能高效的算法，查找链表中倒数第k个位置上的结点（k为正整数）。若查找成功，算法输出该结点的data域的值，并返回1；否则，只返回0。要求：</strong></p><p>1）描述算法的基本设计思想。</p><p>​    设置两个指针pq分别指向该链表头结点，设置i用于计数，每次遍历i++。当i小于K时，只有p指针后移，遍历到第i&gt;=k-1时，q和p一起后移。直到p-&gt;next==NULL,若遍历此时小于k-1则说明链表没有k个元素查找失败，否则查找成功打印q-&gt;data;</p><p>2）描述算法的详细实现步骤。</p><ol><li>设置指针p,q指向该链表头结点,设置i=0用于计录遍历次数</li><li>当p-&gt;next != NULL执行3，否则执行5</li><li>判断i，如果i&gt;=k-1，q指针后移一位，执行4</li><li>p指针后移一位，i=i+1，执行2</li><li>判断如果 i &gt;= k-1，则查找成功，输出该结点的data域的值，并返回1；否则查找失败返回0</li><li>程序结束</li></ol><p>3）根据设计思想和实现步骤，采用程序设计语言描述算法（使用C、C++或Java语言实现），关键之处请给出简要注释。</p><pre class=" language-c++"><code class="language-c++">int findIndexK(LinkList &L,int k){    int i = 0;            //i用于计录遍历次数,初始化为0    LNode *p,*q;    p = L;                 //遍历链表的指针指向头结点    q = L;                //遍历链表的指针指向头结点    while(p->next){        if(i>=k-1){        //当i=k-1时，p指向第k个元素；此时q应该指向第一个元素。            q = q->next;//q指针后移一位        }        p=p->next        //每次循环p都后移一位        i++;            //每次循环i都加一    }    if(i>=k-1){            //i表示有多少元素，如果i<k-1,元素个数不够k查找失败否则查找成功        cout<< q->data;        return 1;    }else{        return 0;    }}</code></pre><p>(4)算法的时间和空间复杂度</p><p>算法的基本操作为p=p-&gt;next;该操作执行的次数为f(n) =$n$,所以算法的时间复杂度为$T(n)=O(n)$,由于算法需要的额外辅助空间与规模n无关，变化属于常量级别，所以空间复杂度为O(1)</p><p><strong>22.【2012统考真题】假定采用带头结点的单链表保存单词，当两个单词有相同的后级时，可共享相同的后级存储空间，例如，“loading”和“being”的存储映像如下图所示。</strong></p><p><img src="../../medias/images/image-20210810093850099.png" alt="image"></p><p><strong>设str1和str2分别指向两个单词所在单链表的头结点，链表结点结构为[data|next]，请设计一个时间上尽可能高效的算法，找出由str1和str2所指向两个链表共同后级的起始位置（如图中字符i所在结点的位置p）。要求：</strong><br>1）给出算法的基本设计思想。</p><ol><li><p>设置两个指针p,q分别指向两个单链表</p></li><li><p>循环遍历p，每遍历一个结点就扫描q所指链表检查是否为公共结点：p = q</p></li><li><p>如果有公共结点，那么就打印该结点</p></li><li><p>如果没有，程序结束</p><p>①分别求出str1和str2所指的两个链表的长度m和n。</p><p>②将两个链表以表尾对齐：令指针p、g分别指向str1和str2的头结点，若m≥n，则指针p先走，使p指向链表中的第m-n+1个结点；若m&lt;n，则使q指向链表中的第n-m+1个结点，即使指针p和q所指的结点到表尾的长度相等。<br>③反复将指针p和q同步向后移动，当p、g指向同一位置时停止，即为共同后缀的起始位置，算法结束。</p></li></ol><p>2）根据设计思想，采用C或C++或Java语言描述算法，关键之处给出注释。</p><pre class=" language-c++"><code class="language-c++">void findCommon(LinkList str1,LinkList str2){    LNode *p,*q;    p = str1->next;    while(p){        q = str2->next;        while(q){            if(q == p){                cout<< q->data<< endl;                return;            }            q = q->next;        }        p = p->next;    }}</code></pre><p>3）说明你所设计算法的时间复杂度。</p><p>​        该算法的基本操作为q = q-&gt;next;，最坏的情况是没有公共结点，每遍历L1的一个结点就必须遍历整个L2，需要执行的次数f(n)=mn,时间复杂度T(n)= O(nm)</p><p>由于算法需要的额外辅助空间与规模n无关，变化属于常量级别，所以空间复杂度为O(1)</p><p><strong>23.【2015统考真题】用单链表保存m个整数，结点的结构为[data] [link]，且|data|≤n（n为正整数）。现要求设计一个时间复杂度尽可能高效的算法，对于链表中data的绝对值相等的结点，仅保留第一次出现的结点而删除其余绝对值相等的结点。例如，若给定的单链表head如下：</strong></p><p><img src="../../medias/images/image-20210810094055787.png" alt="image"></p><p>则删除结点后的head为<img src="../../medias/images/image-20210810094117456.png" alt="image"></p><p>要求：<br>1）给出算法的基本设计思想。</p><p>​    设置循环指针r和临时指针temp；每次判断r和r的后续结点是否相等，若相等就使用temp删除释放后继结点，若不等r后移r后继不等与NULL执行2，r的后继为空，程序结束</p><p>正确思路：算法的核心思想是用空间换时间。使用辅助数组记录链表中已出现的数值，从而只需对链表进行一趟扫描。<br>因为|data|≤n，故辅助数组q的大小为n+1，各元素的初值均为0。依次扫描链表中的各结点，同时检查q[|data|]的值，若为0则保留该结点，并令g[|data|]=1；否则将该结点从链表中删除。</p><p>2）使用C或C++语言，给出单链表结点的数据类型定义。</p><pre class=" language-C++"><code class="language-C++">#define elemtype int        //定义默认数据类型typedef struct node{    elemtype data;          //elemtype类型的数据域    struct node *next;        //指向该类型结点的指针域}LNode,*LinkList;            //LNode强调这是结点，LinkList强调这是链表</code></pre><p>3）根据设计思想，采用C或C++语言描述算法，关键之处给出注释。</p><pre class=" language-C++"><code class="language-C++">void deleteExcessElem(LinkList &head){    LNode *r,*temp;        //设置两个结点指针    r = head->next;        //指针r指向链表开始结点    while(r->next){        //当链表r的有后继结点执行循环        temp = r->next;    //temp指向r的后继结点        if(abs(temp->data) == abs(r->data)){        //如果temp和r的data的绝对值相等            r->next = temp->next;                    //r结点的指针指向temp的后继结点            free(temp);                                //删除释放temp所指结点        }        r = r->next;                                //r后移一位    }}</code></pre><p>4）说明你所设计算法的时间复杂度和空间复杂度。</p><p>​    算法的基本操作为循环体中的部分，所以该部分的执行次数f(n) = n,时间复杂度为T(n)=O(n),由于算法需要的额外辅助空间与规模n无关，变化属于常量级别，所以空间复杂度为O(1)</p><p><strong>24.设计一个算法完成以下功能：判断一个链表是否有环，如果有，找出环的入口点并返回，否则返回NULL。</strong></p><p>(1)算法的基本设计思想</p><p>设置结构体时多加一项用于记录是否已读，如果当前结点存在并且isread==0那么从头开始一直遍历，每次遍历修改isread=1.结束循环遍历时如果是因为结点为空则表示无环反之表示有换，遍历指针所指就是环的入口</p><p>题解思路：</p><p>​        设置快慢两个指针分别为fast和slow，初始时都指向链表头head。slow每次走一步，即slow=slow-&gt;next；fast 每次走两步，即fast=fast-&gt;next-&gt;next。由于fast比slow走得快，如果有环，那么fast一定会先进入环，而slow后进入环。当两个指针都进入环后，经过若干操作后两个指针定能在环上相遇。这样就可以判断一个链表是否有环。</p><p>​        如下图所示，当slow刚进入环时，fast早已进入环。因为fast每次比slow多走一步且fast与slow的距离小于环的长度，所以fast与slow相遇时，slow所走的距离不超过环的长度。<img src="../../medias/images/image-20210815000237893.png" alt="image-20210815000237893"></p><p>如下图所示，设头结点到环的入口点的距离为a，环的入口点沿着环的方向到相遇点的距离为x，环长为r，相遇时fast绕过了n圈。<img src="../../medias/images/image-20210815000305019.png" alt="image-20210815000305019"></p><p>则有$2（a+x）=a+n<em>r+x $，即a=n</em>r-x。显然从头结点到环的入口点的距离等于n倍的环长减去环的入口点到相遇点的距离。因此可设置两个指针，一个指向head，一个指向相遇点，两个指针同步移动（均为一次走一步），相遇点即为环的入口点。</p><p>(2)算法描述</p><pre class=" language-c++"><code class="language-c++">#define elemtype int        //定义默认数据类型typedef struct node{    elemtype data;          //elemtype类型的数据域    int isread;                //判断是否已读,初始化时值为0    struct node *next;        //指向该类型结点的指针域}LNode,*LinkList;            //LNode强调这是结点，LinkList强调这是链表LNode *isRound(LinkList L){    LNode *r = L->next;    while(r->isread == 0&&r){        r->isread = 1;        r = r->next;    }    if(r){        return r;    }else{        return NULL;    }}</code></pre><p>(3)算法的时间和空间复杂度</p><p>算法的基本操作为r-&gt;isread = 1;r = r-&gt;next;，所以该部分的执行次数f(n) = n,时间复杂度为T(n)=O(n),由于算法需要的额外辅助空间与规模n无关，变化属于常量级别，所以空间复杂度为O(1)</p><p>25.<strong>【2019统考真题】设线性表$L=(a_1,a_2,a_3,…,a_{n-2},a_{n-1},a_{n})$​采用带头结点的单链表保存，链表中的结点定义如下：</strong></p><pre class=" language-c++"><code class="language-c++">typedef struct node{    int data;    struct node*next;   }NODE;</code></pre><p>请设计一个空间复杂度为O(1)且时间上尽可能高效的算法，重新排列L中的各结点，得到线性表$L=(a_1,a_n,a_2,a_{n-1},a_{3},a_{n-2},…)$​​​。要求：<br>1）给出算法的基本设计思想。</p><p>把L看做两个链表，前n/2个为L1，后n/2个为L2。把L2逆置为a_n,a_{n-1},…a_{n/2}，然后依次把L2的元素插入L1各个元素的后面得到线性表$L=(a_1,a_n,a_2,a_{n-1},a_{3},a_{n-2},…)$。</p><p>2）根据设计思想，采用C或C++语言描述算法，关键之处给出注释。</p><pre class=" language-c++"><code class="language-c++">void fun(LinkList &L){    int i = 0,k = 0;    LNode *p,*temp,*r,*q;    p = L->next;    r = L;    while(p){        i++;        p = p->next;    }    (i%2==0)?k = i/2:k = i/2+1;    for(i = 0;i < k;i++){        r = r->next;    }    q = r->next;    r->next = NULL;    while(q){            //逆置为a_n,a_{n-1},...a_{n/2}        temp = q;        q = q->next;        temp->next = r->next;        r->next = temp;    }    while(p!=r){        //把后n/2个元素依次插入前面各个元素的后面的位置        temp = r->next;        r->next = temp->next;        temp->next = p->next;        p->next = temp;        p = temp->next;    }}</code></pre><p>3）说明你所设计的算法的时间复杂度。</p><p>​    算法的基本操作为四个循环的部分，所以该部分的执行次数$f(n) = n+\frac n2+\frac n2+\frac n2$,时间复杂度为T(n)=O(n),由于算法需要的额外辅助空间与规模n无关，变化属于常量级别，所以空间复杂度为O(1)</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> data_structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tree</title>
      <link href="posts/tree.html"/>
      <url>posts/tree.html</url>
      
        <content type="html"><![CDATA[<h1 id="抽象数据结构"><a href="#抽象数据结构" class="headerlink" title="抽象数据结构"></a><strong>抽象数据结构</strong></h1><pre class=" language-markdown"><code class="language-markdown">ADT BinaryTree{<span class="token code keyword">    数据对象D:D是具有相同特性的数据元素的集合。</span><span class="token code keyword">    数据关系R：</span><span class="token code keyword">        若D=Φ，则R=Φ，称BinaryTree为空二叉树；</span><span class="token code keyword">        若D≠Φ，则R={H}，H是如下二元关系：</span><span class="token code keyword">            （1）在D中存在唯一的称为根的数据元素root，它在关系H下无前驱；</span><span class="token code keyword">            （2）若D-{root}≠Φ，则存在D-{root}={D_l，D_r}，且D_l∩D_r=Φ；</span><span class="token code keyword">            （3）若D_l≠Φ，则D_l中存在唯一的元素x_l，&lt;root,x_l>∈H，且存在D_l上的关系H_l∈H;若D_r≠Φ，则D_r中存在唯一的元素x_r，&lt;root，x_r>∈H，且存在D_r上的关系H_r∈H；H={&lt;root,x_l>,&lt;root,x_r>，H_l,H_r}；</span><span class="token code keyword">            （4）(D_1,{H_l})是一棵符合本定义的二又树，称为根的左子树，(D_1,{H_r})是一棵符合本定义的二叉树，称为根的右子树。</span><span class="token code keyword">    基本操作P：</span><span class="token code keyword">        InitBiTree(&amp;T);</span><span class="token code keyword">            操作结果：构造空二叉树T。</span><span class="token code keyword">        DestroyBiTree(&amp;T);</span><span class="token code keyword">            初始条件：二叉树T存在。武跑国读干市</span><span class="token code keyword">            操作结果：销毁二叉树T。</span><span class="token code keyword">        CreateBiTree(&amp;T,definition);</span><span class="token code keyword">            初始条件：definition给出二又树T的定义。</span><span class="token code keyword">            操作结果：按definition构造二叉树T </span><span class="token code keyword">        ClearBiTree(&amp;T);</span><span class="token code keyword">            初始条件：二又树T存在。</span><span class="token code keyword">            操作结果：将二又树T清为空树。</span><span class="token code keyword">        BiTreeEmpty(T);</span><span class="token code keyword">            初始条件：二又树T存在。</span><span class="token code keyword">            操作结果：若T为空二又树，则返回TRUE，否则BALSE。</span><span class="token code keyword">        BiTreeDepth(T);</span><span class="token code keyword">            初始条件：二又树T存在。</span><span class="token code keyword">            操作结果：返回T的深度。</span><span class="token code keyword">        Root(T);</span><span class="token code keyword">            初始条件：二又树T存在。</span><span class="token code keyword">            操作结果：返回T的根。</span><span class="token code keyword">        value(T,e);</span><span class="token code keyword">            初始条件：二叉树T存在，e是T中某个结点。</span><span class="token code keyword">            操作结果：返回e的值。</span><span class="token code keyword">        Assign(T,&amp;e,value);</span><span class="token code keyword">            初始条件：二又树T存在，e是T中某个结点</span><span class="token code keyword">            操作结果：结点e赋值为value。</span><span class="token code keyword">        Parent(T,e);</span><span class="token code keyword">            初始条件：二又树T存在，e是T中某个结点。</span><span class="token code keyword">            操作结果：若e是T的非根结点，则返回它的双亲，否则返回“空”。</span><span class="token code keyword">        LeftChild(T,e);</span><span class="token code keyword">            初始条件：二又树T存在，e是T中某个结点。</span><span class="token code keyword">            操作结果：返回e的左孩子。若e无左孩子，则返回“空”。</span><span class="token code keyword">        RightChild(T,e);</span><span class="token code keyword">            初始条件：二又树T存在，e是T中某个结点。</span><span class="token code keyword">            操作结果：返回e的右孩子。若e无右孩子，则返回“空”。</span><span class="token code keyword">        LeftSibling(T,e);</span><span class="token code keyword">            初始条件：二叉树T存在，e是T中某个结点。</span><span class="token code keyword">            操作结果：返回e的左兄弟。若e是T的左孩子或无左兄弟，则返回“空”。</span><span class="token code keyword">        RightSibling(T,e);</span><span class="token code keyword">            初始条件：二叉树T存在，e是T中某个结点。</span><span class="token code keyword">            操作结果；返回e的右兄弟。若。是T的右孩子或无右兄弟，则返回“空”。</span><span class="token code keyword">        Insertchild(T,p,LR,c);</span><span class="token code keyword">            初始条件：二又树T存在，p指向T中某个结点，LR为0或1，非空二树c与T不相交且右子树为空。</span><span class="token code keyword">            操作结果：根据LR为0或1，插入c为T中p所指结点的左或右子树。p所指结点的原有左或右子树则成为c的右子树。</span><span class="token code keyword">        Deletechild(T,p,LR);</span><span class="token code keyword">            初始条件：二又树T存在，p指向T种某个结点，LR为0或1.</span><span class="token code keyword">            操作结果：根据LR为0或1，删除T中p所指结点的左或右子树</span><span class="token code keyword">        PreOrderTraverse(T,Visit());</span><span class="token code keyword">            初始条件：二叉树T存在，Visit是对结点操作的应用函数。</span><span class="token code keyword">            操作结果：先序遍历T，对每个结点调用函数Visit一次且仅一次。一旦visit（）失败，则操作失败。</span><span class="token code keyword">        InOrderTraverse(T,Visit());</span><span class="token code keyword">            初始条件：二叉树T存在，Visit是对结点操作的应用函数。</span><span class="token code keyword">            操作结果：中序遍历T，对每个结点调用函数Visit一次且仅一次。一旦visit（）失败，则操作失败。</span><span class="token code keyword">        PostOrderTraverse(T,Visit());</span><span class="token code keyword">            初始条件：二叉树T存在，Visit是对结点操作的应用函数。</span><span class="token code keyword">            操作结果：后序遍历T，对每个结点调用函数Visit一次且仅一次。一旦visit（）失败，则操作失败。</span><span class="token code keyword">        LevelOrderTraverse(T,Visit());</span><span class="token code keyword">            初始条件：二又树T存在，Visit是对结点操作的应用函数。</span><span class="token code keyword">            操作结果：层序遍历T，对每个结点调用函数Visit一次且仅一次。一旦visit（）失败，则操作失败。</span>}ADT BinaryTree</code></pre><h1 id="树的存储"><a href="#树的存储" class="headerlink" title="树的存储"></a>树的存储</h1><h2 id="双亲表示法——顺序存储"><a href="#双亲表示法——顺序存储" class="headerlink" title="双亲表示法——顺序存储"></a>双亲表示法——顺序存储</h2><h3 id="结点描述"><a href="#结点描述" class="headerlink" title="结点描述"></a>结点描述</h3><pre class=" language-c++"><code class="language-c++">#define MAX_TREE_SIZE 100    //树中最多结点数typedef struct{                //树的结点定义    ElemType data;            //数据元素    int parent;                //双亲位置域}PTNode;typedef struct{                //树的类型定义    PTNode nodes[MAX_TREE_SIZE];//双亲表示    int n；                    //结点数}PTree;</code></pre><p>顺序存储结点数据，结点中保存父节点在数组中的下标;根结点固定存储在0，parent=-1表示没有双亲</p><p>优点：找双亲节点方便；</p><p>缺点：找孩子不方便</p><p><img src="C:\Users\我有一个龙宝\AppData\Roaming\Typora\typora-user-images\image-20210828212211369.png" alt="image-20210828212211369"></p><h2 id="孩子表示法——顺序-链式存储"><a href="#孩子表示法——顺序-链式存储" class="headerlink" title="孩子表示法——顺序+链式存储"></a>孩子表示法——顺序+链式存储</h2><h3 id="结点描述-1"><a href="#结点描述-1" class="headerlink" title="结点描述"></a>结点描述</h3><pre class=" language-c++"><code class="language-c++">struct CTNode{    int child;                //孩子结点在数组中的位置    struct CTNode *next;    //下一个孩子}CTNode;typedef struct{    ElemType data;    struct CTNode *firstChild;    //第一个孩子}CTBox;typedef struct{    CTBox nodes[MAX_TREE_SIZE];    int n,r;                    //结点数和根的位置}CTree;</code></pre><p>孩子表示法：数组包含全部结点，把他们的孩子依次挂载到他们的指针域后</p><p><img src="C:\Users\我有一个龙宝\AppData\Roaming\Typora\typora-user-images\image-20210828213240304.png" alt="image-20210828213240304"></p><h2 id="孩子兄弟表示法——链式存储"><a href="#孩子兄弟表示法——链式存储" class="headerlink" title="孩子兄弟表示法——链式存储"></a>孩子兄弟表示法——链式存储</h2><h3 id="结点描述-2"><a href="#结点描述-2" class="headerlink" title="结点描述"></a>结点描述</h3><pre class=" language-c++"><code class="language-c++">//树的存储——孩子兄弟表示法typedef struct CSNode{    ElemType data;        //数据域    struct CSNode *firstchild,*nextsibling;        //第一个孩子和右兄弟指针}CSNode，*CSTree；</code></pre><p>树和二叉树的转换（手算）：</p><ol><li>把所有的结点与它的兄弟结点连接起来</li><li>除了一个结点和其左孩子的连线，把与其它孩子结点的连线去除</li><li>新形成的兄弟结点间的连线向下旋转45°</li></ol><p><img src="C:\Users\我有一个龙宝\AppData\Roaming\Typora\typora-user-images\image-20210828213831520.png" alt="image-20210828213831520"></p><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h2><p>结点描述</p><pre class=" language-c++"><code class="language-c++">#define MaxSize 100struct TreeNode{    elemType value;        //结点中的数据元素    bool isEmpty;        //结点是否为空};    TreeNode t[MaxSize];    //定义一个长度为MaxSize的数组t，按照从上至下、从左至右的顺序依次存储完全二叉树中的各个结点</code></pre><p>让第一个位置空缺，保证数组下标和结点标号一致</p><p><img src="C:\Users\我有一个龙宝\AppData\Roaming\Typora\typora-user-images\image-20210829190530007.png" alt="image-20210829190530007"><img src="C:\Users\我有一个龙宝\AppData\Roaming\Typora\typora-user-images\image-20210829190649409.png" alt="image-20210829190649409"></p><p>顺序存储方式最适合用来存储完全二叉树，存储一般的二叉树太浪费存储空间</p><p>几个重要常考的基本操作：</p><ul><li>i的左孩子——2i</li><li>i的右孩子——2i+1</li><li>i的父节点——$\lfloor\frac i2\rfloor$</li><li>i所在的层次——$\lceil\log_2(n+1)\rceil或\lfloor\log_2n\rfloor+1$</li></ul><p><strong>完全二叉树</strong>中共有n个结点，则</p><ul><li><p>判断i是否有左孩子？——$2i\le n?$</p></li><li><p>判断i是否有右孩子？——$2i+1\le n?$</p></li><li><p>判断i是否是叶子/分支结点？——$i&gt;\frac n2?$</p></li></ul><h2 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h2><h3 id="结点描述-3"><a href="#结点描述-3" class="headerlink" title="结点描述"></a>结点描述</h3><pre class=" language-c++"><code class="language-c++">#define datatype chartypedef struct Node{    datatype data;    struct Node *lchild ,*rchild;}BinNode,*BinTree;</code></pre><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <cstdlib>#define datatype char#define maxsize 1024using namespace std;typedef struct Node{    datatype data;    struct Node *lchild ,*rchild;}BinNode,*BinTree;void CreateBinTree(BinTree &T);                             //先序创建二叉树void InOrderTraverse(BinTree T);                            //中序遍历void PreOrderTraverse(BinTree T);                           //先序遍历void PostOrderTraverse(BinTree T);                          //后序遍历void Copy(BinTree T,BinTree &NewT);                         //二叉树的复制int Depth(BinTree T);                                       //树的深度int NodeCount(BinTree T);                                   //统计二叉树中结点的个数int LeafCount(BinTree T);                                   //统计二叉树中叶子结点的个数int Node_1_Count(BinTree T);                                //统计二叉树的度为1的结点个数void PrintAllPath(BinTree T, char path[], int pathlen);     //二叉树中从每个叶子结点到根结点的路径void ExChangeTree(BinTree &T);                              //构造函数，使用递归算法进行左右结点转换void DblOrderTraverse(BinTree T);                           //二叉树的双序遍历int main(){         //测试例子AB#CD##E##F#GH###    BinTree t;    char path[maxsize];    CreateBinTree(t);    InOrderTraverse(t);    cout<<endl;    PreOrderTraverse(t);    cout<<endl;    PostOrderTraverse(t);    cout<<endl;    BinTree NewT;    Copy(t,NewT);    InOrderTraverse(NewT);    cout<<endl;    InOrderTraverse(t);    cout<<endl;    cout<<Depth(t)<<endl;    cout<<NodeCount(t)<<endl;    cout<<LeafCount(t)<<endl;    cout<<Node_1_Count(t)<<endl;    PrintAllPath(t,path,0);    ExChangeTree(t);    InOrderTraverse(t);    cout<<endl;    DblOrderTraverse(t);    return 0;}void CreateBinTree(BinTree &T){    datatype n;    cin>>n;    if(n == '#'){        T = NULL;    }    else{        BinTree temp = (BinNode *)malloc(sizeof(BinNode));        temp->data = n;        T = temp;         CreateBinTree(T->lchild);        CreateBinTree(T->rchild);    }}void InOrderTraverse(BinTree T){    if(T){        InOrderTraverse(T->lchild);        cout<<T->data;        InOrderTraverse(T->rchild);    }}void PreOrderTraverse(BinTree T){    if(T){        cout<<T->data;        PreOrderTraverse(T->lchild);        PreOrderTraverse(T->rchild);    }}void PostOrderTraverse(BinTree T){    if(T){        PostOrderTraverse(T->lchild);        PostOrderTraverse(T->rchild);        cout<<T->data;    }}void Copy(BinTree T,BinTree &NewT){    NewT = T;    // if(T==NULL){    //     NewT=NULL;    //     return;    // }else    // {    //     NewT=new BiTNode;    //     NewT->data=T->data;    //     Copy(T->lchild,NewT->lchild);    //     Copy(T->rchild,NewT->rchild);    // }}int Depth(BinTree T){    if(!T){        return 0;    }    else{        int m = Depth(T->lchild);        int n = Depth(T->rchild);        int depth = m>n?m:n;        return depth + 1;    }}int NodeCount(BinTree T){    if(!T)return 0;    return NodeCount(T->lchild)+NodeCount(T->rchild)+1;}int LeafCount(BinTree T){    if(!T)return 0;    if(!T->lchild&&!T->rchild)return 1;    else{        return LeafCount(T->lchild)+LeafCount(T->rchild);    }}int Node_1_Count(BinTree T){    if(!T)return 0;    if(T->lchild&&!T->rchild)return 1+Node_1_Count(T->lchild);    else if(!T->lchild&&T->rchild)return 1+Node_1_Count(T->rchild);    else{        return Node_1_Count(T->lchild)+Node_1_Count(T->rchild);    }}void PrintAllPath(BinTree T, char path[], int pathlen){    if(T){        path[pathlen] = T->data;        if(!T->lchild&&!T->rchild){            for(int i = pathlen;i >= 0;i--)                cout<<path[i]<<" ";            cout<<endl;        }else{            PrintAllPath(T->lchild,path,pathlen+1);            PrintAllPath(T->rchild,path,pathlen+1);                }            }}void ExChangeTree(BinTree &T){    if(!T->lchild&&!T->rchild)return;    BinNode *temp = T->lchild;    T->lchild = T->rchild;    T->rchild = temp;    if(T->lchild)    ExChangeTree(T->lchild);    if(T->rchild)    ExChangeTree(T->rchild);    // BinTree temp;    // if(T!=NULL){//判断T是否为空，非空进行转换，否则不转换    //     temp=T->lchild;    //     T->lchild=T->rchild;//直接交换节点地址    //     T->rchild=temp;    //     ExChangeTree(T->lchild);    //     ExChangeTree(T->rchild);    // }}void DblOrderTraverse(BinTree T){    if(T)    {        cout<<T->data;        DblOrderTraverse(T->lchild);        cout<<T->data;//访问两遍        DblOrderTraverse(T->rchild);    }}</code></pre><h3 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h3><ul><li><p>算法思想：</p><ul><li><p>①初始化一个辅助队列</p></li><li><p>②根结点入队</p></li><li><p>③若队列非空，则队头结点出队，访问该结点，并将左、右孩子插入队尾（如果有的话）</p></li><li><p>④重复③直至队列为空</p></li></ul></li><li><p>算法实现</p><pre class=" language-c++"><code class="language-c++">void level(BinTree T){    BinTree Q[maxsize];    int front = 0,rear = maxsize-1;    if(T){        rear = (rear+1)%maxsize;        Q[rear] = T;    }else        return;    BinNode *temp = NULL;    while(Q[front]){        temp = Q[front];        front = (front+1)%maxsize;        cout<< temp->data<<endl;        if(temp->lchild){            rear = (rear+1)%maxsize;            Q[rear] = temp->lchild;        }        if(temp->rchild){            rear = (rear+1)%maxsize;            Q[rear] = temp->rchild;        }    }}</code></pre><h3 id="层次遍历应用"><a href="#层次遍历应用" class="headerlink" title="层次遍历应用"></a>层次遍历应用</h3><p>【例6-5】假设二叉树采用二叉链表存储结构存储，设计一个算法，<strong>求出该二叉树的宽度</strong>（具有结点数最多的那一层上的结点个数）。</p><p>算法思想：</p><p>采用层次遍历，在队列数组足够大的时候，二叉树的结点就会按照层次遍历的顺序保存在队列中，我们只需要给每个结点设置一个标记。通过该标记表示他在第几层，最后通过比较再输出二叉树的最大宽度</p><p>算法实现</p><pre class=" language-c++"><code class="language-c++">typedef struct{    BinNode *BN;    int num;}BT;int maxNode(BinTree T){    BT Q[maxsize];    int front = 0,rear = -1;    int n,t,max=0;    if(T){        rear = rear+1;        Q[rear].BN = T;        Q[rear].num = 1;    }else        return 0;    BinNode *temp = NULL;    while(front != rear+1){        temp = Q[front].BN;        n = Q[front].num;        front = front+1;        if(temp->lchild){            rear = rear+1;            Q[rear].BN = temp->lchild;            Q[rear].num = n+1;        }        if(temp->rchild){            rear = rear+1;            Q[rear].BN = temp->rchild;            Q[rear].num = n+1;        }    }    front = 0;    int i = 0;    i = Q[front].num;    t = 1;    while(front<rear){        if(Q[front+1].num == i){            t++;        }else{            i = Q[front+1].num;            max = max>t?max:t;            t = 1;        }        front ++;    }    max = max>t?max:t;    return max;}</code></pre></li></ul><h1 id="深度优先遍历算法的非递归实现"><a href="#深度优先遍历算法的非递归实现" class="headerlink" title="深度优先遍历算法的非递归实现"></a>深度优先遍历算法的非递归实现</h1><h2 id="先序遍历非递归算法"><a href="#先序遍历非递归算法" class="headerlink" title="先序遍历非递归算法"></a>先序遍历非递归算法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>​    定义一个栈代替递归算法中的栈</p><ul><li>根结点先入栈</li><li>出栈，把该结点的左右孩子结点按“先右后左”的顺序入栈（如果有左右孩子结点的话）</li><li>直到栈空</li></ul><h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><pre class=" language-c++"><code class="language-c++">void preorderNonrecursion(BTNode *bt){    if(bt != NULL){        BTNode *Stack[maxSize];        //定义一个栈        int top = -1;                //初始化栈        BTNode *p;        Stack[++top] = bt;            //根结点入栈        while(top != -1){            //栈空循环退出，遍历结束            p = Stack[top--];            //出栈并输出栈顶结点            Visit(p);                    //visit（）为访问p的函数            if(p->rchild != NULL)        //栈顶结点的右孩子存在，则右孩子入栈                        Stack[++top] = p->rchild;            if(p->1child != NULL)        //栈顶结点的左孩子存在，则左孩子入栈                stack[++top] = p->1child;        }    }}</code></pre><h2 id="中序遍历非递归算法"><a href="#中序遍历非递归算法" class="headerlink" title="中序遍历非递归算法"></a>中序遍历非递归算法</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>定义一个栈代替递归算法中的栈</p><ol><li>根结点先入栈</li><li>如果栈顶结点有左孩子结点的话,左孩子入栈；</li><li>否者栈顶结点出栈，如果出栈结点有右孩子结点的话,右孩子入栈；</li><li>重复23</li><li>直到栈空</li></ol><h3 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h3><pre class=" language-c++"><code class="language-c++">void inorderNonrecursion(BTNode *bt){    BTNode *p;    if(bt){        BTNode *stack[maxsize];        //maxsize已定义，用于确定数组的最大值        int top = -1;                //初始化栈        p = bt;/*下边这个循环完成中序遍历。注意：图6-13所示的进栈、出栈过程在⑦中会出现栈空状态，但这时遍历还没有结束，因根结点的右子树还没有遍历，此时p非空，根据这一点来维持循环的进行*/        while(top != -1||p != NULL){            while(p != NULL){        //左孩子存在，则左孩子入栈                stack[++top] = p;                p = p->lchild;            }            if(top != -1){            //在栈不空的情况下出栈并输出出栈结点                p = stack[top--];                visit(p);            //Visit（）是访问p的函数，在这里执行打印结点值的操作                p = p->rchild;            }        }    }}</code></pre><h2 id="后序遍历非递归算法"><a href="#后序遍历非递归算法" class="headerlink" title="后序遍历非递归算法"></a>后序遍历非递归算法</h2><h3 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h3><p>​    先序遍历左右子树交换</p><h3 id="算法实现-3"><a href="#算法实现-3" class="headerlink" title="算法实现"></a>算法实现</h3><pre class=" language-c++"><code class="language-c++">void postorderNonrecursion(BTNode *bt){    if(bt != NULL){        BTNode *Stack1[maxSize];        //定义一个栈        BTNode *Stack2[maxSize];        //定义一个栈        int top1 = -1,top2 = -1;        //初始化栈        BTNode *p;        Stack1[++top1] = bt;            //根结点入栈        while(top1 != -1){            //栈空循环退出，遍历结束            p = Stack1[top1--];            //出栈并输出栈顶结点            Stack2[++top2] = p;                    if(p->1child != NULL)        //栈顶结点的左孩子存在，则左孩子入栈                stack1[++top1] = p->1child;            if(p->rchild != NULL)        //栈顶结点的右孩子存在，则右孩子入栈                            Stack1[++top1] = p->rchild;        }        while(top2 != -1){            p = Stack2[top2--];            Visit(p);                    //visit（）为访问p的函数    }}</code></pre><h1 id="二叉树的线索化"><a href="#二叉树的线索化" class="headerlink" title="二叉树的线索化"></a>二叉树的线索化</h1><p>线索二叉树方便从一个指定结点出发，找到其前驱、后继；方便遍历</p><p>二又树被线索化后近似于一个线性结构，分支结构的遍历操作就转化为了近似于线性结构的遍历操作，通过线索的辅助使得寻找当前结点前驱或者后继的平均效率大大提高。</p><p>二叉树的线索化实际上就是<strong>二叉树的前（中后）序遍历的拓展应用</strong></p><h3 id="中序线索化算法思想"><a href="#中序线索化算法思想" class="headerlink" title="中序线索化算法思想"></a>中序线索化算法思想</h3><ul><li><p>从根节点出发，重新进行一次中序遍历，指针q记录当前访问的结点，指针pre记录上一个被访问的结点（即q的前驱）</p></li><li><p>先递归处理左子树</p></li><li><p>再处理根结点</p></li><li><p>再递归处理右子树</p></li><li><p>递归处理过程为：</p><ul><li><p>①当q-&gt;lchild==NULL时，q-&gt;lchild就指向前驱pre，并把令ltag=1；</p></li><li><p>②当pre!=NULL&amp;&amp;pre-&gt;rchild==NULL时，pre-&gt;rchild指向后继q，并令pre-&gt;rtag = 1</p></li><li><p>③处理完当前节点后令pre=p</p></li></ul></li></ul><h3 id="具体算法实现"><a href="#具体算法实现" class="headerlink" title="具体算法实现"></a>具体算法实现</h3><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <cstdlib>#define DataType charusing namespace std;/*线索存储标志位Link(0)：表示指向左右孩子的指针Thread(1):表示指向前驱后继的线索*/typedef enum{Link,Thread} PointerTag;typedef struct BiThrNode{    DataType data;    struct BiThrNode *lchild,*rchild;    PointerTag ltag;    PointerTag rtag;}BiThrNode, *BiThrTree;//全局变量，始终指向刚刚访问过的节点//BiThrTree pre = NULL;void createBiThrTree(BiThrTree &T);     //创建一棵二叉树，前序遍历输入数据void inThreading(BiThrTree T);          //中序遍历线索化void createInThread(BiThrNode *root);    //创建中序线索树void InOrderThreading(BiThrTree T);     //中序遍历线索二叉树---非递归//ABDH##I##E##CF##G##int main(){    BiThrTree T;    createBiThrTree(T);    createInThread(T);    InOrderThreading(T);    return 0;}//创建一棵二叉树，前序遍历输入数据void createBiThrTree(BiThrTree &T){    char data;    cin>>data;    if(data == '#') T = NULL;    else{        T = (BiThrNode *)malloc(sizeof(BiThrNode));        T->data = data;        T->ltag = Link;        T->rtag = Link;        createBiThrTree(T->lchild);        createBiThrTree(T->rchild);    }}void createInThread(BiThrNode *root){    BiThrNode *pre=NULL;            //前驱结点指针        if(root!=NULL){            InOrderThreading(root,pre);            pre->rchild = NULL;        //非空二叉树，线索化            pre->rtag = Thread;        //后处理中序最后一个结点        }}//中序遍历线索化void inThreading(BiThrTree T,BiThrNode *&pre){    if(T){        inThreading(T->lchild);        if(!T->lchild){            T->ltag = Thread;            T->lchild = pre;        }        if(pre&&!pre->rchild){            pre->rtag = Thread;            pre->rchild = T;        }        pre = T;        inThreading(T->rchild);    }}//前序遍历线索化void preThreading(BiThrTree T,BiThrNode *&pre){    if(T){        if(!T->lchild){            T->ltag = Thread;            T->lchild = pre;        }        if(pre&&!pre->rchild){            pre->rtag = Thread;            pre->rchild = T;        }        pre = T;        if(T->ltag == Link)        //注意这里递归入口有限制条件，左右指针不是线索才继续递归        preThreading(T->lchild);        if(T->rtag == Link)        preThreading(T->rchild);    }}//后序遍历线索化void postThreading(BiThrTree T,BiThrNode *&pre){    if(T){        postThreading(T->lchild);        postThreading(T->rchild);        if(!T->lchild){            T->ltag = Thread;            T->lchild = pre;        }        if(pre&&!pre->rchild){            pre->rtag = Thread;            pre->rchild = T;        }        pre = T;    }}//先序遍历线索二叉树---非递归void preOrderThreading(BiThrTree T){    if(T){        BiThrTree p = T;        while(p){            while(p->ltag == Link){                visit(p);                p = p->lchild;            }            visit(p);            p = p->rchild;        }    }}//中序遍历线索二叉树---非递归void InOrderThreading(BiThrTree T){    BiThrTree b = T;    while(b){        while(b->ltag == Link){            b = b->lchild;        }        cout<<b->data;        while(b->rchild&&b->rtag == Thread){            b = b->rchild;            cout<<b->data;        }        b = b->rchild;     }    cout<<endl;}//中序遍历线索二叉树---非递归/************************************************************************///找到以P为根的子树中，第一个被中序遍历的结点BiThrNode *Firstnode(BiThrNode *p){//循环找到最左下结点（不一定是叶结点）    while(p->ltag == Link)        p = p->lchild;    return p;}//在中序线索二叉树中找到结点p的后继结点BiThrNode *Nextnode(BiThrNode *p){//右子树中最左下结点    if(p->rtag == Link)        return Firstnode(p->rchild);    else return p->rchild;    //rtag==1直接返回后继线索}//对中序线索二叉树进行中序遍历（利用线索实现的非递归算法）void Inorder(BiThrNode*T){    for(BiThrNode*p=Firstnode(T);p != NULL; p = Nextnode(p))        visit(p);}/************************************************************************/</code></pre><h1 id="二叉树，树，森林之间的转化"><a href="#二叉树，树，森林之间的转化" class="headerlink" title="二叉树，树，森林之间的转化"></a>二叉树，树，森林之间的转化</h1><h2 id="树转化为二叉树"><a href="#树转化为二叉树" class="headerlink" title="树转化为二叉树"></a>树转化为二叉树</h2><ol><li><p>将同一结点的各孩子结点用线（图6-20中的虚线所示）串起来，如图6-20所示。</p></li><li><p>将每个结点的分支从左往右除了第一个以外，其余的都剪掉，如图6-21所示，即可得到如图6-22a所示的二叉树。</p></li><li><p>调整结点使之符合二又树的层次结构，如图6-22b所示。</p><p><img src="C:\Users\我有一个龙宝\AppData\Roaming\Typora\typora-user-images\image-20210831221327462.png" alt="image-20210831221327462"><img src="C:\Users\我有一个龙宝\AppData\Roaming\Typora\typora-user-images\image-20210831221337465.png" alt="image-20210831221337465"></p></li></ol><h2 id="二叉树转化为树"><a href="#二叉树转化为树" class="headerlink" title="二叉树转化为树"></a>二叉树转化为树</h2><ol><li>先把它从左上到右下分为若干层</li><li>然后调整成水平方向</li><li>找到每一层结点在其上一层的父结点</li><li>将每一层的结点和其父结点相连</li><li>然后删除每一层结点之间的连接</li></ol><p><img src="C:\Users\我有一个龙宝\AppData\Roaming\Typora\typora-user-images\image-20210831221833200.png" alt="image-20210831221833200"></p><h2 id="森林转化为二叉树"><a href="#森林转化为二叉树" class="headerlink" title="森林转化为二叉树"></a>森林转化为二叉树</h2><ol><li><p>先将森林中的树分别转化为二叉树</p></li><li><p>将转化后的二叉树的根结点依次相连</p></li><li><p>调整</p><p><img src="C:\Users\我有一个龙宝\AppData\Roaming\Typora\typora-user-images\image-20210831222120320.png" alt="image-20210831222120320"><img src="C:\Users\我有一个龙宝\AppData\Roaming\Typora\typora-user-images\image-20210831222134417.png" alt="image-20210831222134417"></p></li></ol><h2 id="二叉树转化为森林"><a href="#二叉树转化为森林" class="headerlink" title="二叉树转化为森林"></a>二叉树转化为森林</h2><ol><li>将根结点有右孩子的二叉树的右孩子连接断开</li><li>将多棵二叉树转化为树，即可得到原森林</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>树的先根遍历=森林的先序遍历=二叉树的先序遍历</p><p>树的后根遍历=森林的中序遍历=二叉树的中序遍历</p><h1 id="树与二叉树的应用"><a href="#树与二叉树的应用" class="headerlink" title="树与二叉树的应用"></a>树与二叉树的应用</h1><h2 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h2><h3 id="二叉排序树的定义"><a href="#二叉排序树的定义" class="headerlink" title="二叉排序树的定义"></a>二叉排序树的定义</h3><p>一棵二叉树或者是空二叉树，或者是具有如下性质的二叉树：</p><ul><li>左子树上所有结点的关键字均小于根结点的关键字；</li><li>右子树上所有结点的关键字均大于根结点的关键字。</li><li>左子树和右子树又各是一棵二叉排序树。</li></ul><p>默认不允许两个结点的关键字相同</p><h3 id="二叉排序树的算法实现"><a href="#二叉排序树的算法实现" class="headerlink" title="二叉排序树的算法实现"></a>二叉排序树的算法实现</h3><pre class=" language-c++"><code class="language-c++"></code></pre><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> data_structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String</title>
      <link href="posts/string.html"/>
      <url>posts/string.html</url>
      
        <content type="html"><![CDATA[<h1 id="串的定义"><a href="#串的定义" class="headerlink" title="串的定义"></a>串的定义</h1><h2 id="定长顺序存储"><a href="#定长顺序存储" class="headerlink" title="定长顺序存储"></a>定长顺序存储</h2><p>静态数组实现①</p><pre class=" language-c++"><code class="language-c++">#define MAXLEN 255    //预定义最大串长为255typedef struct {    char ch[MAXLEN];//每个分量存储一个字符    int length;        //串的实际长度}SString;</code></pre><pre class=" language-c++"><code class="language-c++">#define MAXSTRLEN 255    //预定义最大串长为255typedef unsigned char SString[MAXSTRLEN+1] //0号单元存放穿的长度</code></pre><h2 id="堆分配存储-动态数组实现"><a href="#堆分配存储-动态数组实现" class="headerlink" title="堆分配存储(动态数组实现)"></a>堆分配存储(动态数组实现)</h2><pre class=" language-c++"><code class="language-c++">typedef struct{    char *ch;        //按串长分配存储区，Ch指向串的基地址    int length;        //串的长度}HString;HString S;S.ch = (char *)malloc(sizeof(char)*MAXLEN);S.length = 0;</code></pre><h2 id="串的链式存储"><a href="#串的链式存储" class="headerlink" title="串的链式存储"></a>串的链式存储</h2><pre class=" language-c++"><code class="language-c++">typedef struct StringNode{    char ch;            //每个结点存1个字符    struct StingNode *next;}StringNode,*string;</code></pre><h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><pre class=" language-markdown"><code class="language-markdown">ADT String{<span class="token code keyword">    数据对象:    D = {a_i|a_i∈CharacterSet,i=1,2,...n,n≥0}</span><span class="token code keyword">    数据关系:    R_1 = {&lt;a_{i-1},a_i>|a_{i-1},a_i∈D,i=1,2,...n}</span><span class="token code keyword">    基本操作:</span><span class="token code keyword">        StrAssign(&amp;T,chars);        //chars是字符串常量,生成一个其值等于chars的串T</span><span class="token code keyword">        StrCopy(&amp;T,S);                //串S存在,由串S复制得串T</span><span class="token code keyword">        StrEmpty(S);                //串S存在,若S为空串，则返回TRUE，否则返回FALSE</span><span class="token code keyword">        StrCompare(S,T);            //串S,T存在,若S>T,则返回值>0;若S=T,则返回值=0;若S&lt;T,则返回值&lt;0.</span><span class="token code keyword">        StrLength(S);                //串S存在,返回S的元素个数，称为串的长度</span><span class="token code keyword">        ClearString(&amp;S);            //串S存在,将S清为空串</span><span class="token code keyword">        Concat(&amp;T,S1,S2);            //串S1,S2存在,用T返回由S1和S2联结而成的新串</span><span class="token code keyword">        SubString(&amp;Sub,S,pos,len);    //串S存在,1&lt;=pos&lt;=StrLength(S)且0&lt;=len&lt;=StrLength(S)-pos+1/用Sub返回串S的第pos个字符起长度为len的子串</span><span class="token code keyword">        Index(S,T,pos);                //串S,T存在,T是非空串,1&lt;=pos&lt;=StrLength(S),r若主串S存在和串T值相同的子串，则返回它在主串S中第pos个字符之后第一次出现的位置;否则返回0</span><span class="token code keyword">        Replace(&amp;S,T,V);            //串S,T,V存在,T是非空串,用V替换主串S中出现的所有与T相等的不重叠的子串</span><span class="token code keyword">        StrInsert(&amp;S,pos,T);        //串S,T存在,1&lt;=pos&lt;=StrLength(S)+1,在串S的第pos个字符之前插入串T</span><span class="token code keyword">        StrDlete(&amp;S,pos,len);        //串S存在,1&lt;=pos&lt;=StrLength(S)+1/从串S中删除第pos个字符起长度为len的子串</span><span class="token code keyword">        DestoryString(&amp;S);            //串S存在,串S被撤销</span>}ADT String</code></pre><h1 id="串变长存储的实现"><a href="#串变长存储的实现" class="headerlink" title="串变长存储的实现"></a>串变长存储的实现</h1><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <cstdlib>#define DataType int    //定义串中元素的数据类型#define MAXLEN 1024        //定义串中元素的最大个数using namespace std;typedef struct{    char *ch;        //按串长分配存储区，Ch指向串的基地址    int length;        //串的长度}HString;bool InitString(HString &S);            // 串的初始化 bool StrAssign(HString &T,char chars[]);//chars是字符串常量,生成一个其值等于chars的串Tbool StrCopy(HString &T,S);                //串S存在,由串S复制得串Tbool StrEmpty(HString S);                //串S存在,若S为空串，则返回TRUE，否则返回FALSEint StrCompare(HString S,HString T);    //串S,T存在,若S>T,则返回值>0;若S=T,则返回值=0;若S<T,则返回值<0.int StrLength(HString S);                //串S存在,返回S的元素个数，称为串的长度bool ClearString(HString &S);            //串S存在,将S清为空串bool Concat(HString &T,HString S1,HString S2);//串S1,S2存在,用T返回由S1和S2联结而成的新串bool SubString(HString &Sub,HString S,int pos,int len);    //串S存在,1<=pos<=StrLength(S)且0<=len<=StrLength(S)-pos+1/用Sub返回串S的第pos个字符起长度为len的子串bool Index(HString S,HString T,pos);    //串S,T存在,T是非空串,1<=pos<=StrLength(S),r若主串S存在和串T值相同的子串，则返回它在主串S中第pos个字符之后第一次出现的位置;否则返回0bool Replace(HString &S,T,V);            //串S,T,V存在,T是非空串,用V替换主串S中出现的所有与T相等的不重叠的子串bool StrInsert(HString &S,pos,T);        //串S,T存在,1<=pos<=StrLength(S)+1,在串S的第pos个字符之前插入串Tbool StrDlete(HString &S,pos,len);        //串S存在,1<=pos<=StrLength(S)+1/从串S中删除第pos个字符起长度为len的子串bool DestoryString(HString &S);            //串S存在,串S被撤销int main(){    HString S;    InitString(S);    StrAssign(S,"cur input")}// 串的初始化 bool InitString(HString &S){    S.ch = (char *)malloc(sizeof(char)*MAXLEN);    S.length = 0;}//chars是字符串常量,生成一个其值等于chars的串Tbool StrAssign(HString &T,char chars[]){    char *c = chars;    int len = 0;    if(T.ch){        free(T.ch);        T.ch = NULL;        T.length = 0;    }    while(*c){        ++int;        ++c;    }    if(len == 0){        return false;    }else{        T.ch = (char *)malloc(sizeof(char)*len);        if(!T.ch)            return 0;        c = chars;        for(int i = 0;i<len;i++,c++){            T.ch[i] = *c;        }        T.length = len;        return true;    }}//串S,T存在,若S>T,则返回值>0;若S=T,则返回值=0;若S<T,则返回值<0.int StrCompare(HString S,HString T){    for(int i = 0;i<S.length&&i<T.length;i++){        if(S.ch[i]!=T.ch[i]){            return S.ch[i]-T.ch[i];        }    }    return S.length-T.length;}//串S存在,返回S的元素个数，称为串的长度int StrLength(HString S){    return S.length;}//串S存在,将S清为空串bool ClearString(HString &S){    if(S.ch){        free(S.ch);        S.ch = NULL;        S.length = 0;    }    return true;}            //串S1,S2存在,用T返回由S1和S2联结而成的新串bool Concat(HString &T,HString S1,HString S2){    if(T.ch){        free(T.ch);        T.ch = NULL;        T.length = 0;    }    T.ch = (char*)malloc(sizeof(char)*(S1.length+S2.length));    if(!T.ch)        return false;    T.length = S1.length+S2.length;    int i,j;    for(i = 0;i<S1.length;i++){        T.ch[i] = S1.ch[i];    }    for(j = 0;j<S1.length;j++){        T.ch[i+j] = S1.ch[j];    }    return true;}//串S存在,1<=pos<StrLength(S)且0<=len<=StrLength(S)-pos/用Sub返回串S的第pos个字符起长度为len的子串bool SubString(HString &Sub,HString S,int pos,int len){    if(pos < 0||pos >= S.length||len < 0||len > S.length-pos)        return 0;    if(Sub.ch){        free(Sub.ch);        Sub.ch=NULL;    }    if(len == 0){        Sub.ch = NULL;        Sub.length = 0;        return true;    }else{        Sub.ch = (char*)malloc(sizeof(char)*len);        if(!Sub.ch)return false;        Sub.length = len;        int i = pos;        int j = 0;        while(i<pos+len){            Sub.ch[j] = S.ch[i];            i++;            j++;        }        return true;    }</code></pre><h1 id="串的匹配算法"><a href="#串的匹配算法" class="headerlink" title="串的匹配算法"></a>串的匹配算法</h1><h2 id="简单模式匹配"><a href="#简单模式匹配" class="headerlink" title="简单模式匹配"></a>简单模式匹配</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><ul><li>主串长度n，模式串长度m</li><li>将主串中所有长度为m的子串依次与模式串对比</li><li>对比失败， ij回溯：i=i-j+2; j=1;</li><li>找到第一个与模式串匹配的子串，并返回子串起始位置</li><li>若所有子串都不匹配，则返回0</li></ul><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><pre class=" language-c++"><code class="language-c++">int index(Hstring T,HString S){    int i=1,j=1;    while(i<=T.length&&j<=S.length){        if(T.ch[i]==S.ch[j]){            i++;            j++;        }else{            i=i-j+2;            j=1;        }    }    if(S.length<j){        return i-S.length;    }    else        return 0;}</code></pre><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>最坏的情况，每个子串都要对比m个字符，共n-m+1个子串，复杂度=O（（n-m+1）m）=O（nm）</p><p>最好的情况，每个子串的第一个字符就匹配失败，共n-m+1个子串，复杂度=O（n-m+1）=O（n）</p><h2 id="字符串的前缀、后缀和部分匹配值"><a href="#字符串的前缀、后缀和部分匹配值" class="headerlink" title="字符串的前缀、后缀和部分匹配值"></a>字符串的前缀、后缀和部分匹配值</h2><p>要了解子串的结构，首先要弄清楚几个概念：前缀、后缀和部分匹配值。</p><ul><li><p>前缀指除最后一个字符以外，字符串的所有头部子串；</p></li><li><p>后缀指除第一个字符外，字符串的所有尾部子串；</p></li><li><p>部分匹配值则为字符串的前缀和后缀的最长相等前后缀长度。</p></li><li><p>下面以ababa’为例进行说明：<br>‘a’的前缀和后缀都为空集，最长相等前后缀长度为0。<br>‘ab’的前缀为{a}，后缀为{b}，{a}∩{b}=0，最长相等前后缀长度为0。<br>‘aba’的前缀为{a，ab}，后缀为{a，ba}，{a，ab}∩{a，ba}={a}，最长相等前后缀长度为1。<br>‘abab’的前缀{a，ab，aba}∩后缀{b，ab，bab}={ab}，最长相等前后缀长度为2。<br>‘ababa’的前缀{a，ab，aba，abab}∩后缀{a，ba，aba，baba}={a，aba}，公共元素有两个，最长相等前后缀长度为3。<br>故字符串’ababa’的部分匹配值为00123.<br>部分匹配值后移一位：前面补零，消除最后一位所有的加一就是next[]数组对应的值</p></li></ul><p>next[i]的含义是：在子串的第i个字符与主串发生失配时，则跳到子串的next[i]位置重新与主串当前位置进行比较。</p><p>$next[j]=\begin{cases}0,&amp;j=1\\max\left{k|1&lt;k&lt;j且’P_1…P_{k-1}’=’P_{j-k+1}…P_{j-1}’\right},&amp; 当此集合空时\1,&amp;其他情况\end{cases}$</p><p><img src="../../medias/images/image-20210824233349103.png" alt="image-20210824233349103"><img src="../../medias/images/image-20210824234229246.png" alt="image-20210824234229246"></p><h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><ul><li>主串长度n，模式串长度m</li><li>将主串中所有长度为m的子串依次与模式串对比</li><li>对比失败， j回溯：j=next[j];</li><li>找到第一个与模式串匹配的子串，并返回子串起始位置</li><li>若所有子串都不匹配，则返回0</li></ul><h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><pre class=" language-c++"><code class="language-c++">void get_next(String T,int next[]){    int i=1,j=0;    next[1]=0;    while(i<T.length){        if(j == 0||T.ch[i] == T.ch[j]}{           ++i;           ++j;           next[i]=j;        //若p_i=p_j，则next[j+1]=next[j]+1       }else           j=next[j];        //否则令j=next[j]，循环继续    }}           void get_nextval(String T, int nextval[]){    int i=1,j=0;    nextval[1]=0;    while(i<T.length){        if(j==0||T. ch[i]==T. ch[j]){            ++i;            ++j;             if(T.ch[i] != T. ch[j])                nextval[i] = j;             else                 nextval[i] = nextval[j];        }        else j=nextval[j];    }}           int index_KMP(Hstring T,HString S){    int i=1,j=1;    while(i<=T.length&&j<=S.length){        if(j==0||T.ch[i]==S.ch[j]){            i++;            j++;        }else{            j=next[j];        }    }    if(S.length<j){        return i-S.length;    }    else        return 0;}</code></pre><h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><p>KMP算法，最坏时间复杂度O（m+n）其中，求next数组时间复杂度O（m）</p><p>模式匹配过程最坏时间复杂度O（n）</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> data_structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>The application of the stack</title>
      <link href="posts/the-application-of-the-stack.html"/>
      <url>posts/the-application-of-the-stack.html</url>
      
        <content type="html"><![CDATA[<h1 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h1><p>分析</p><ol><li>遇到左括号入栈</li><li>遇到右括号出栈（如果栈为空，则匹配失败）</li><li>判断当前情况（如果出栈左括号和当前右括号是一种类型匹配成功，否则失败）</li><li>循环123步</li><li>如果当前栈为空，则括号序列匹配成功</li></ol><p>算法实现</p><pre class=" language-c++"><code class="language-c++">#define maxSize 100            //设置栈长度的最大值typedef struct{    char data[maxSize];    int top;}SequenceStack;void InitStack(SequenceStack &S);            //初始化bool IsEmpty(SequenceStack S);                //判空void pop(SequenceStack &S,char &topElem);    //取栈顶元素void push(SequenceStack &S,char elem);        //入栈        bool bracketCheck(char Str[],int length){     SequenceStack S;     InitStack(S);     for(int i = 0;i < length;i++){         if(Str[i] == '('||Str[i] == '['||Str[i] == '{'){             push(S,Str[i]);         }else{             if(IsEmpty(S))                 return false;             char topElem;             pop(S,topElem);             if(Str[i] == ')'&&topElem != '(')                 return false;             if(Str[i] == ']'&&topElem != '[')                 return false;             if(Str[i] == '}'&&topElem != '{')                 return false;         }           }    return IsEmpty(S); }</code></pre><h1 id="后缀表达式求值"><a href="#后缀表达式求值" class="headerlink" title="后缀表达式求值"></a>后缀表达式求值</h1><p>【例3-2】编写一个函数，求后缀式的数值，其中后缀式存于一个字符数组exp中，exp中最后一个字符为“\0”，作为结束符，并且假设后缀式中的数字都只有一位。本题中所出现的除法运算，皆为整除运算，如2/3结果为0、3/2结果为1。</p><p>算法分析</p><ul><li>①从左往右扫描下一个元素，直到处理完所有元素</li><li>②若扫描到操作数则压入栈，并回到①；否则执行③</li><li>③若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，回到①<br>注意：先出栈的是“右操作数”</li></ul><p>算法实现</p><pre class=" language-c++"><code class="language-c++">int count(int a,char op,int b){    if(op == "-")        return a-b;    if(op == "+")        return a+b;    if(op == "*")        return a*b;    if(op == "/"){        if(b == 0)            cout<< err<< endl;        return 0;    }else{        return a-b;       }}int com(char exp[]){    int stack[maxsize];    int top = -1,a,b,d;    char op;    for(int i=0;exp[i]!='\0';i++){        if(exp[i]>='0'&&exp[i]<='9')            stack[++top] = exp[i]-'0';        else{            b = stack[top--]-'0';            a = stack[top--]-'0';            d = count(a,exp[i],b);            stack[++top] = d;        }    }    return stack[top];}</code></pre><h1 id="循环链表表示队列"><a href="#循环链表表示队列" class="headerlink" title="循环链表表示队列"></a>循环链表表示队列</h1><ul><li><p>假设以带头结点的循环链表表示队列，并且只设一个指针指向队尾结点，但不设头指针，请写出相应的入队列和出队列算法。</p><pre class=" language-c++"><code class="language-c++">void enqueue(LinkLsit &r,elemtype x){    LNode *temp = (LNode*)malloc(sizeof(LNode));    if(!temp)return;    temp->data = x;    temp->next = r->next;    r->next = temp;    r = temp;}void dequeue(LinkLsit &r,elemtype &x){    LNode *temp;    if(r->next == r)return;    if(r->next->next == r){        temp = r;        r = r->next;        x = temp->data;        r->next = r;        free(temp);    }else{        temp = r->next->next;        r->next->next = temp->next;        x = temp->data;        free(temp);    }}</code></pre></li><li><p>如果允许在循环队列的两端都可以进行插入和删除操作，要求：</p><p>1）写出循环队列的类型定义。</p><pre class=" language-c++"><code class="language-c++">#define maxsize 10            //设置队列长度的最大值typedef struct queue{    int elem[maxsize];    int rear,front;    int length;}queue;</code></pre><p>2）分别写出从<u>队尾删除</u>和从<u>队头插入</u>的算法。</p><pre class=" language-c++"><code class="language-c++">void enHeadQueue(queue &q,elemtype x){    if(q.length == maxsize)return;    q.elem[(q.front+maxsize-1)%maxsize] = x;    q.front = (q.front+maxsize-1)%maxsize;    q.length ++;}void deRearQueue(queue &q,elemtype &x){    if(q.length == 0)return;    x = q.elem[q.rear];    q.rear = (q.rear+maxsize-1)%maxsize;}</code></pre></li><li><p>设计一个循环队列，用front和rear分别作为队头和队尾指针，另外用一个标志tag表示队列是空还是不空，约定当tag为0时队空，当tag为1时队不空，这样就可以用front==rear作为队满的条件。要求，设计队列的结构和相关基本运算算法（队列元素为int型）。</p><pre class=" language-c++"><code class="language-c++">#define maxsize 10            //设置队列长度的最大值typedef struct queue{    int elem[maxsize];    int rear,front;    int tag;}queue;void init(queue &q){    q.rear=q.front=0;    tag=0;}bool isEmpty(queue q){    if(q.rear==q.front&&tag==0)        return true;    return false;}bool isFull(queue q){    if(q.rear==q.front&&tag==1)        return true;    return false;}bool EnQueue(queue &q,int e){        //插入元素e为新的队尾元素（队列Q已存在）    if(isFull(q)){        return false;    }else{        q.elem[(q.rear+1)%maxsize] = e;        q.rear=(q.rear+1)%maxsize;        tag = 1;        return true;    }}bool DeQueue(queue &q,int &e){        //删除Q的队头元素，并用e返回其值。（队列Q已存在）    if(isEmpty(q))return false;    e = q.elem[(q.front-1+maxsize)%maxsize];    q.front=(q.front-1+maxsize)%maxsize    tag = 0;    return true;}</code></pre></li><li><p>编写一个算法，将一个非负的十进制整数N转换为一个二进制数。</p><pre class=" language-c++"><code class="language-c++">int stack[maxsize];int top = -1;void translate(int a,int stack[],int top){    int i;    i = a;    while(i){        stack[++top] = i%2;        i = i/2;    }    int result = 0    while(top!=-1){        int a = stack[top--];        result = result*10+a;    }    cout<< result<<endl;}</code></pre></li><li><p>试编写一个算法，检查一个程序中的花括号、方括号和圆括号是否配对，若全部配对，则返回1，否则返回0。对于程序中出现的一对单引号或双引号内的字符不进行括号配对检查。39为单引号的ASCll值，34为双引号的ASCII值，单引号和双引号如果出现则必成对出现。<br>假设stack是已经定义的顺序栈结构体。可以直接调用的元素进栈/出栈、取栈顶元素、判断栈空的函数定义如下：</p><pre class=" language-c++"><code class="language-c++">void push(stack &S,char ch);void pop(stack &S,char &ch);void getTop(stack S,char &ch);int isEmpty(stack S);    //若栈s空，则返回1，否则返回0</code></pre><pre class=" language-c++"><code class="language-c++">int check(char str[]){    stack  *S;    for(int i = 0;str[i]!='\0';i++){        if(str[i]=='('||str[i]=='['||str[i]=='{'||str[i]==39||str[i]==34){            push(S,str[i])        }        if(IsEmpty(S))            return false;        char top =  getTop(S,top);        if(top =='('&&str[i]==')'||top =='['&&str[i]==']'||top =='{'&&str[i]=='}'||top = str[i])            pop(S,top);    }    if(isEmpty(S))return 1;    else return 0;}</code></pre><h1 id="递归与非递归"><a href="#递归与非递归" class="headerlink" title="递归与非递归"></a>递归与非递归</h1><p>求解二次方根$\sqrt A$的迭代函数定义如下：<img src="C:\Users\我有一个龙宝\AppData\Roaming\Typora\typora-user-images\image-20210820233712396.png" alt="image-20210820233712396">式中，p是A的近似二次方根；e是结果允许误差。试写出相应的递归算法和非递归算法（假设取绝对值函数fabs（）可以直接调用)。</p><pre class=" language-c++"><code class="language-c++">int sqrt(int A,int p,int e){    //递归    if(fabs(p*p-A)<e) return p;    return sqrt(A,(p+A/p)/2,e);}int sqrt(int A,int p,int e){    //非递归    while(fabs(p*p-A) >=e){        p = (p+A/p)/2;    }    return p;}</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> data_structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Queue</title>
      <link href="posts/queue.html"/>
      <url>posts/queue.html</url>
      
        <content type="html"><![CDATA[<h1 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h1><h2 id="队列结点描述"><a href="#队列结点描述" class="headerlink" title="队列结点描述"></a>队列结点描述</h2><pre class=" language-c++"><code class="language-c++">#define DataType int#define MaxSize 10typedef struct node{    DataType data[maxsize];    int front,rear;}Node,SqQueue;</code></pre><h2 id="链队结点"><a href="#链队结点" class="headerlink" title="链队结点"></a>链队结点</h2><pre class=" language-c++"><code class="language-c++">#define DataType inttypedef struct node{    DataType data;    struct node * next;}LNode,*LinkNode;typedef struct{    LinkNode *front,*rear;}LinkQueue;</code></pre><h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><pre class=" language-markdown"><code class="language-markdown">ADT Queue{<span class="token code keyword">    数据对象:    D = {a_i|a_i∈Elemset,i=1,2,...n,n≥0}</span><span class="token code keyword">    数据关系:    R_1 = {&lt;a_{i-1},a_i>|a_{i-1},a_i∈D,i=1,2,...n}</span><span class="token code keyword">    基本操作:</span><span class="token code keyword">        InitQueue(&amp;Q);        //构造一个空的队列Q</span><span class="token code keyword">        DestroyQueue(&amp;Q);    //销毁队列Q（队列Q已存在）</span><span class="token code keyword">        ClearQueue(&amp;Q);        //将Q清为空队列(队列Q已存在)</span><span class="token code keyword">        QueueEmpty(Q);        //若Q为空队列，则返回true，否则返回false（队列Q已存在）</span><span class="token code keyword">        QueueLength(Q);        //返回队列Q中元素个数，即队列的长度（队列Q已存在）</span><span class="token code keyword">        GetHead(Q,&amp;e);        //用e返回队头元素。（队列Q已存在）</span><span class="token code keyword">        EnQueue(&amp;Q,e);        //插入元素e为新的队尾元素（队列Q已存在）</span><span class="token code keyword">        DeQueue(&amp;Q,&amp;e);        //删除Q的队头元素，并用e返回其值。（队列Q已存在）</span><span class="token code keyword">        QueueTraverse(Q);    //按前后顺序输出队列Q的所有元素值（队列Q已存在）</span>}ADT Queue</code></pre><h1 id="队列的实现"><a href="#队列的实现" class="headerlink" title="队列的实现"></a>队列的实现</h1><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <cstdlib>#define maxsize 1024#define datatype intusing namespace std;typedef struct node{    datatype data[maxsize];    int front;    int rear;}Node,SqQueue;bool InitQueue(SqQueue &Q);            //构造一个空的队列Qbool DestroyQueue(SqQueue &Q);        //销毁队列Q（队列Q已存在）bool ClearQueue(SqQueue &Q);        //将Q清为空队列(队列Q已存在)bool QueueEmpty(SqQueue Q);            //若Q为空队列，则返回true，否则返回false（队列Q已存在）int QueueLength(SqQueue Q);        //返回队列Q中元素个数，即队列的长度（队列Q已存在）bool GetHead(SqQueue Q,datatype &e);//用e返回队头元素。（队列Q已存在）bool EnQueue(SqQueue &Q,datatype e);//插入元素e为新的队尾元素（队列Q已存在）bool DeQueue(SqQueue &Q,datatype &e);//删除Q的队头元素，并用e返回其值。（队列Q已存在）bool QueueTraverse(SqQueue Q);      //按前后顺序输出队列Q的所有元素值（队列Q已存在）int main(){    int data;    datatype x;    SqQueue q;    InitQueue(q);    cin>>data;    while(data !=-1){        EnQueue(q,data);        cin>>data;    }    QueueTraverse(q);    cout<< QueueLength(q)<< endl;    GetHead(q,x);    cout<< x<< endl;    DeQueue(q,x);    cout<< x<< endl;    QueueTraverse(q);    ClearQueue(q);    QueueTraverse(q);    return 0;}//构造一个空的队列Qbool InitQueue(SqQueue &Q){    Q.front = 0;    Q.rear = 0;    return true;}//将Q清为空队列(队列Q已存在)bool ClearQueue(SqQueue &Q){    Q.front = Q.rear = 0;    return true;}        //若Q为空队列，则返回true，否则返回false（队列Q已存在）bool QueueEmpty(SqQueue Q){    return(Q.front == Q.rear);}//返回队列Q中元素个数，即队列的长度（队列Q已存在）int QueueLength(SqQueue Q){    return (Q.rear-Q.front);}//用e返回队头元素。（队列Q已存在）bool GetHead(SqQueue Q,datatype &e){    if(!QueueEmpty(Q))return false;    e = Q.data[Q.front];    return true;}//插入元素e为新的队尾元素（队列Q已存在）bool EnQueue(SqQueue &Q,datatype e){    if(Q.rear == maxsize)return false;    Q.data[Q.rear] = e;    Q.rear++;}//删除Q的队头元素，并用e返回其值。（队列Q已存在）bool DeQueue(SqQueue &Q,datatype &e){    if(!QueueEmpty(Q))return false;    e = Q.data[Q.front];    Q.front++;}//按前后顺序输出队列Q的所有元素值（队列Q已存在）bool QueueTraverse(SqQueue Q){    if(!QueueEmpty(Q))return false;    for(int i = Q.front; i< Q.rear;i++){        cout<< Q.data[i];    }    cout<< endl;}</code></pre><h1 id="循环队列的实现"><a href="#循环队列的实现" class="headerlink" title="循环队列的实现"></a>循环队列的实现</h1><pre class=" language-c++"><code class="language-c++">#include < iostream >#include < cstdlib >#define maxsize 1024#define datatype intusing namespace std;typedef struct node{    datatype data[maxsize];    int front;    int rear;}Node,SqQueue;bool InitQueue(SqQueue &Q);            //构造一个空的队列Qbool DestroyQueue(SqQueue &Q);        //销毁队列Q（队列Q已存在）bool ClearQueue(SqQueue &Q);        //将Q清为空队列(队列Q已存在)bool QueueEmpty(SqQueue Q);            //若Q为空队列，则返回true，否则返回false（队列Q已存在）int QueueLength(SqQueue Q);        //返回队列Q中元素个数，即队列的长度（队列Q已存在）bool GetHead(SqQueue Q,datatype &e);//用e返回队头元素。（队列Q已存在）bool EnQueue(SqQueue &Q,datatype e);//插入元素e为新的队尾元素（队列Q已存在）bool DeQueue(SqQueue &Q,datatype &e);//删除Q的队头元素，并用e返回其值。（队列Q已存在）bool QueueTraverse(SqQueue Q);      //按前后顺序输出队列Q的所有元素值（队列Q已存在）int main(){    int data;    datatype x;    SqQueue q;    InitQueue(q);    cin>>data;    while(data !=-1){        EnQueue(q,data);        cin>>data;    }    QueueTraverse(q);    cout<< QueueLength(q)<< endl;    GetHead(q,x);    cout<< x<< endl;    DeQueue(q,x);    cout<< x<< endl;    QueueTraverse(q);    ClearQueue(q);    QueueTraverse(q);    return 0;}//构造一个空的队列Qbool InitQueue(SqQueue &Q){    Q.front = Q.rear =0;    return true;}//将Q清为空队列(队列Q已存在)bool ClearQueue(SqQueue &Q){    Q.front = Q.rear = 0;    return true;}        //若Q为空队列，则返回true，否则返回false（队列Q已存在）bool QueueEmpty(SqQueue Q){    return(Q.front == Q.rear);}//返回队列Q中元素个数，即队列的长度（队列Q已存在）int QueueLength(SqQueue Q){    return (Q.rear+maxsize-Q.front)%maxsize;}//用e返回队头元素。（队列Q已存在）bool GetHead(SqQueue Q,datatype &e){    if(QueueEmpty(Q))return false;    e = Q.data[Q.front];    return true;}//插入元素e为新的队尾元素（队列Q已存在）bool EnQueue(SqQueue &Q,datatype e){    if((Q.rear+1)%maxsize == Q.front)return false;    Q.data[Q.rear] = e;    Q.rear=(Q.rear+1)%maxsize;    return true;}//删除Q的队头元素，并用e返回其值。（队列Q已存在）bool DeQueue(SqQueue &Q,datatype &e){    if(QueueEmpty(Q))return false;    e = Q.data[Q.front];    Q.front=(Q.front+1)%maxsize;    return true;}//按前后顺序输出队列Q的所有元素值（队列Q已存在）bool QueueTraverse(SqQueue Q){    if(QueueEmpty(Q))return false;    for(int i = Q.front; (i+1)%maxsize != Q.rear;i=(i+1)%maxsize){        cout<< Q.data[i];    }    cout<< endl;}</code></pre><p>循环队列是改进的顺序队列</p><p><strong>循环队列</strong>牺牲一个存储单元来<strong>区别队空和队满</strong>！</p><table><thead><tr><th align="center">区别</th><th align="center">顺序队列</th><th align="center">循环队列</th></tr></thead><tbody><tr><td align="center">队空</td><td align="center">front = rear</td><td align="center">front = rear</td></tr><tr><td align="center">队满</td><td align="center">rear = MaxSize</td><td align="center">（rear+1）%MaxSize = front</td></tr><tr><td align="center">入队</td><td align="center">rear++</td><td align="center">rear=（rear+1）%MaxSize</td></tr><tr><td align="center">出队</td><td align="center">front++</td><td align="center">front=（front+1）%MaxSize</td></tr><tr><td align="center">元素个数</td><td align="center">rear-front</td><td align="center">(rear-front+MaxSize)%MaxSize</td></tr></tbody></table><p>要求循环队列不能牺牲一个存储单元来区别队空和队满</p><p>①在结构体里直接加size记录队列元素个数</p><p>②在结构体里加入一个tag（每次删除操作成功时，都令tag=0；每次插入操作成功时，都令tag=1；）</p><p>判空：front = rear&amp;&amp;tag=0（只有删除操作，才可能导致队空）</p><p>队满：front = rear&amp;&amp;tag=1（只有插入操作，才可能导致队满）</p><h1 id="链队的实现"><a href="#链队的实现" class="headerlink" title="链队的实现"></a>链队的实现</h1><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <cstdlib>#define MaxSize 1024#define DataType intusing namespace std;typedef struct node{    DataType data;    struct node * next;}LNode,*LinkNode;typedef struct link{    LinkNode front,rear;}LinkQueue;bool InitQueue(LinkQueue &Q);            //构造一个空的队列Qbool DestroyQueue(LinkQueue &Q);        //销毁队列Q（队列Q已存在）bool ClearQueue(LinkQueue &Q);        //将Q清为空队列(队列Q已存在)bool QueueEmpty(LinkQueue Q);            //若Q为空队列，则返回true，否则返回false（队列Q已存在）int QueueLength(LinkQueue Q);        //返回队列Q中元素个数，即队列的长度（队列Q已存在）bool GetHead(LinkQueue Q,DataType &e);//用e返回队头元素。（队列Q已存在）bool EnQueue(LinkQueue &Q,DataType e);//插入元素e为新的队尾元素（队列Q已存在）bool DeQueue(LinkQueue &Q,DataType &e);//删除Q的队头元素，并用e返回其值。（队列Q已存在）bool QueueTraverse(LinkQueue Q);      //按前后顺序输出队列Q的所有元素值（队列Q已存在）int main(){    int n;    LinkQueue Q;    InitQueue(Q);    cin>>n;    while(n!=-1){        EnQueue(Q,n);        cin>>n;    }    cout<<QueueLength(Q)<<endl;    DeQueue(Q,n);    cout<<n<<endl;    GetHead(Q,n);    cout<<n<<endl;    QueueTraverse(Q);    cout<<QueueLength(Q)<<endl;    return 0;}//构造一个空的队列Q(带头结点)bool InitQueue(LinkQueue &Q){    Q = (LinkQueue)malloc(sizeof(LinkQueue));    Q.front= Q.rear = NULL;}//销毁队列Q（队列Q已存在）bool DestroyQueue(LinkQueue &Q){    free(Q);}//将Q清为空队列(队列Q已存在)bool ClearQueue(LinkQueue &Q){    Q.rear = NULL;    Q.front = NULL;}//若Q为空队列，则返回true，否则返回false（队列Q已存在）bool QueueEmpty(LinkQueue Q){    return (Q.front == NULL||Q.rear == NULL);}//返回队列Q中元素个数，即队列的长度（队列Q已存在）int QueueLength(LinkQueue Q){    int i = 0;    LinkNode temp = Q.front;    while(temp){        i++;        temp = temp->next;    }    return i;}//用e返回队头元素。（队列Q已存在）bool GetHead(LinkQueue Q,DataType &e){    if(Q.front == NULL) return false;    e = Q.front->data;    return true;}//插入元素e为新的队尾元素（队列Q已存在）bool EnQueue(LinkQueue &Q,DataType e){    LinkNode temp = (LinkNode)malloc(sizeof(LNode));    if(!temp)return false;    temp->data = e;    temp->next = NULL;    if(QueueEmpty(Q)){        Q.front = Q.rear = temp;    }else{        Q.rear->next = temp;        Q.rear = temp;    }    return true;}//删除Q的队头元素，并用e返回其值。（队列Q已存在）bool DeQueue(LinkQueue &Q,DataType &e){    if(QueueEmpty(Q))return false;    LinkNode temp = Q.front;    e = temp->data;    Q.front = temp->next;    if(temp == Q.rear)        Q.rear = Q.front = NULL;    free(temp);    return true;}//按前后顺序输出队列Q的所有元素值（队列Q已存在）bool QueueTraverse(LinkQueue Q){    if(QueueEmpty(Q)) return false;    LinkNode temp = Q.front;    while(temp){        cout<<temp->data;        temp = temp->next;    }    cout<<endl;    return true;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> data_structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stack</title>
      <link href="posts/stack.html"/>
      <url>posts/stack.html</url>
      
        <content type="html"><![CDATA[<h1 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h1><h2 id="顺序栈结点描述"><a href="#顺序栈结点描述" class="headerlink" title="顺序栈结点描述"></a>顺序栈结点描述</h2><pre class=" language-c++"><code class="language-c++">#define DataType int#define maxsize 10typedef struct SequenceStack{    DataType elem[maxsize];    int top;}SequenceStack;</code></pre><h2 id="链栈结点"><a href="#链栈结点" class="headerlink" title="链栈结点"></a>链栈结点</h2><pre class=" language-c++"><code class="language-c++">#define datatype inttypedef struct node{    datatype elem;    struct node *next;}Node,*LinkStack;</code></pre><h2 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h2><pre class=" language-c++"><code class="language-c++">#define Maxsize 10        //定义栈中元素的最大个数typedef struct{    ElemType data[Maxsize]；//静态数组存放栈中元素    int top0；//0号栈顶指针    int top1；//1号栈我顶指针}Shstack；</code></pre><p>栈满条件：top0+1==top1</p><h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><pre class=" language-markdown"><code class="language-markdown">ADT Stack{<span class="token code keyword">    数据对象:    D = {a_i|a_i∈Elemset,i=1,2,...n,n≥0}</span><span class="token code keyword">    数据关系:    R_1 = {&lt;a_{i-1},a_i>|a_{i-1},a_i∈D,i=1,2,...n}</span><span class="token code keyword">    基本操作:</span><span class="token code keyword">        InitStack(&amp;S);        //构造一个空的栈S</span><span class="token code keyword">        DestroyStack(&amp;S);    //销毁栈S（栈S已存在）</span><span class="token code keyword">        ClearStack(&amp;S);        //将S重清为空栈(栈S已存在)</span><span class="token code keyword">        StackEmpty(S);        //若S为空栈，则返回true，否则返回false（栈S已存在）</span><span class="token code keyword">        StackLength(S);        //返回栈S中元素个数，即栈的长度（栈S已存在）</span><span class="token code keyword">        GetTop(S);            //返回栈顶元素。（栈S已存在）</span><span class="token code keyword">        Push(&amp;S,e);//插入元素e为新的栈顶元素（栈S已存在）</span><span class="token code keyword">        Pop(&amp;S,&amp;e);//删除S的栈顶元素，并用e返回其值。（栈S已存在）</span><span class="token code keyword">        PrintStack(S);//按前后顺序输出栈S的所有元素值（栈S已存在）</span>}ADT Stack</code></pre><h1 id="顺序栈的实现"><a href="#顺序栈的实现" class="headerlink" title="顺序栈的实现"></a>顺序栈的实现</h1><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <cstdlib>#define DataType int#define maxsize 1024//定义栈中元素的最大个数using namespace std;typedef struct SequenceStack{    DataType elem[maxsize]; //静态数组存放栈中元素    int top;                //栈顶指针}SequenceStack;bool InitStack(SequenceStack &S);        //构造一个空的栈Sbool ClearStack(SequenceStack &S);        //将S重清为空栈(栈S已存在)bool StackEmpty(SequenceStack S);        //若S为空栈，则返回true，否则返回falseint StackLength(SequenceStack S);        //返回栈S中元素个数，即栈的长度bool GetTop(SequenceStack S,DataType &e);            //返回栈顶元素。bool Push(SequenceStack &S,DataType e);//插入元素e为新的栈顶元素bool Pop(SequenceStack &S,DataType &e);//删除S的栈顶元素，并用e返回其值。 void PrintStack(SequenceStack S);//按前后顺序输出线性表L的所有元素值 int main(){    SequenceStack S;    int e;    InitStack(S);    cin>>e;    while(e!=-1){        Push(S,e);        cin>>e;    }    PrintStack(S);    Push(S,7);    PrintStack(S);    GetTop(S,e);    cout<<  e<<  endl;    Pop(S,e);    cout<<  e<<  endl;    PrintStack(S);    ClearStack(S);    cout<<  StackLength(S)<<  endl;    cout<<  StackEmpty(S)<<  endl;}// 栈的初始化 bool InitStack(SequenceStack &S){    S.top = -1;}//将S重清为空栈(栈S已存在)bool ClearStack(SequenceStack &S){    S.top = -1;}    // 检测栈是否为空 bool StackEmpty(SequenceStack S){    if(S.top == -1)return true;    return false;}// 获取栈中元素个数 int StackLength(SequenceStack S){    return S.top+1;}// 获取栈顶元素 bool GetTop(SequenceStack S,DataType &e){    if(StackEmpty(S))return false;    e = S.elem[S.top];    return true;}// 入栈 bool Push(SequenceStack &S,DataType e){    if(S.top == maxsize-1)return false;    S.elem[++S.top] = e;    return true;}// 出栈 bool Pop(SequenceStack &S,DataType &e){    if(StackEmpty(S))return false;    e = S.elem[S.top--];    return true;}//打印栈void PrintStack(SequenceStack S){    int i = S.top;    while(i>-1){        cout<<  S.elem[i];        i--;    }    cout<<  endl;}</code></pre><h1 id="链栈实现"><a href="#链栈实现" class="headerlink" title="链栈实现"></a>链栈实现</h1><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <cstdlib>#define datatype intusing namespace std;typedef struct node{    datatype elem;    struct node *next;}Node,*LinkStack;bool InitStack(LinkStack &S);        //构造一个空的栈Sbool ClearStack(LinkStack &S);        //将S重清为空栈(栈S已存在)bool StackEmpty(LinkStack S);        //若S为空栈，则返回true，否则返回falseint StackLength(LinkStack S);        //返回栈S中元素个数，即栈的长度bool GetTop(LinkStack S,datatype &e);            //返回栈顶元素。bool Push(LinkStack &S,datatype e);//插入元素e为新的栈顶元素bool Pop(LinkStack &S,datatype &e);//删除S的栈顶元素，并用e返回其值。 void PrintStack(LinkStack S);//按前后顺序输出线性表L的所有元素值 int main(){    LinkStack S;    InitStack(S);    cout<< InitStack(S)<< endl;    cout<< StackEmpty(S)<< endl;    int n;    cin>>n;    while(n != -1){        Push(S,n);        cin>>n;    }    PrintStack(S);    GetTop(S,n);    cout<< n<< endl;    Pop(S,n);    cout<< n<< endl;    cout<< StackLength(S)<< endl;    PrintStack(S);    return 0;}//构造一个空的栈Sbool InitStack(LinkStack &S){    S = (Node *)malloc(sizeof(Node));    if(!S)return false;    S->next = NULL;    return true;}//将S重清为空栈(栈S已存在)bool ClearStack(LinkStack &S){    S->next = NULL;}//若S为空栈，则返回true，否则返回falsebool StackEmpty(LinkStack S){    if(!S->next)return true;    return false;}        //返回栈S中元素个数，即栈的长度int StackLength(LinkStack S){    int length = 0;    LinkStack temp = S->next;    while(temp){        length++;        temp = temp->next;    }    return length;}//返回栈顶元素。bool GetTop(LinkStack S,datatype &e){    if(S->next){        e = S->next->elem;        return true;        }    return false;}//插入元素e为新的栈顶元素bool Push(LinkStack &S,datatype e){    Node * temp = (Node *)malloc(sizeof(Node));    if(!temp)return false;    temp->elem = e;    temp->next=S->next;    S->next = temp;    return true;}//删除S的栈顶元素，并用e返回其值。bool Pop(LinkStack &S,datatype &e){    if(!S->next)return false;    Node * temp = S->next;    e = temp->elem;    S->next = temp->next;    free(temp);    return true;}//按前后顺序输出线性表L的所有元素值 void PrintStack(LinkStack S){    Node * temp = S->next;    while(temp){        cout<<  temp->elem;        temp = temp->next;    }    cout<<  endl;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> data_structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MoreLinkList</title>
      <link href="posts/morelinklist.html"/>
      <url>posts/morelinklist.html</url>
      
        <content type="html"><![CDATA[<h1 id="结点的描述"><a href="#结点的描述" class="headerlink" title="结点的描述"></a>结点的描述</h1><h2 id="单链表结点描述"><a href="#单链表结点描述" class="headerlink" title="单链表结点描述"></a>单链表结点描述</h2><pre class=" language-c++"><code class="language-c++">#define datatype int        //定义默认数据类型 typedef struct node{        //定义单链表结点类型    datatype elem;            //数据域    struct node *next;        //指针域}LNode,*LinkList;</code></pre><h2 id="双链表结点描述"><a href="#双链表结点描述" class="headerlink" title="双链表结点描述"></a>双链表结点描述</h2><pre class=" language-c++"><code class="language-c++">#define datatype int        //定义默认数据类型 typedef struct node{        //定义单链表结点类型    datatype elem;            //数据域    struct node *prior,*next;        //指针域}DLNode,*DLinkList;</code></pre><h2 id="静态链表结点描述"><a href="#静态链表结点描述" class="headerlink" title="静态链表结点描述"></a>静态链表结点描述</h2><pre class=" language-c++"><code class="language-c++">#define datatype int        //定义默认数据类型 #define MaxSize 50            //静态链表最大长度typedef struct{    datatype elem;    int next;                //下一个元素的数组下标}SLinkList[MaxSize];</code></pre><h1 id="链表的实现"><a href="#链表的实现" class="headerlink" title="链表的实现"></a>链表的实现</h1><h2 id="双链表基本操作的实现"><a href="#双链表基本操作的实现" class="headerlink" title="双链表基本操作的实现"></a>双链表基本操作的实现</h2><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <cstdlib>#define datatype intusing namespace std;typedef struct node{    datatype elem;    struct node *prior,*next;}DLNode,*DLinkList;bool InitList(DLinkList &L);//初始化链表bool InsertNextNode(DLNode *L,DLNode *S);//在L结点之后插入S结点bool DeleteNextList(DLNode *L);//删除p结点的后继结点void DestoryList(DLinkList &L);//销毁链表bool HeadInsertList(DLinkList &L);//头插法int LoctionElem(DLinkList L,datatype item);//在表L中查找具有给定关键字值的元素,成功返回下标。 DLNode * GetNode(DLinkList L,int i);//在表L中查找第i的元素,并返回该结点。 void PrintList(DLinkList L);//按前后顺序输出线性表L的所有元素值 int main(){    DLinkList head;    InitList(head);    HeadInsertList(head);    PrintList(head);    cout<< LoctionElem(head,3)<< endl;    DeleteNextList(head);    PrintList(head);    cout<< GetNode(head,2)->elem<< endl;}//初始化链表bool InitList(DLinkList &L){    L = (DLNode *)malloc(sizeof(DLNode)); //初始化头结点    if(!L)return false;//    L->next = NULL;    L->prior = NULL;    return true;}//在L结点之后插入S结点bool InsertNextNode(DLNode *L,DLNode *S){    if(!L||!S)return false;     S->next = L->next;     S->prior = L;     L->next = S;     if(S->next)     S->next->prior = S;}//删除p结点的后继结点bool DeleteNextList(DLNode *L){    DLNode *temp;    if(!L||!L->next)return false;    temp = L->next;    L->next = temp->next;    if(temp->next)        temp->next->prior = L;    free(temp);    return true;}//销毁链表void DestoryList(DLinkList &L){    while(L->next){        DeleteNextList(L);    }    free(L);//释放头结点    L=NULL;//头指针指向NULL}//头插法bool HeadInsertList(DLinkList &L){    int x;    cin>>x;    while(x!=-1){        DLNode *temp = (DLNode *)malloc(sizeof(DLNode));        if(!temp) return false;        temp->elem = x;        temp->next = NULL;        InsertNextNode(L,temp);        cin>>x;    }    return true;}//在表L中查找具有给定关键字值的元素,成功返回下标。int LoctionElem(DLinkList L,datatype item){    DLinkList temp = L->next;    int i = 0;    while(temp){        i++;        if(temp->elem == item)return i;        temp = temp->next;    }    return -1;}//在表L中查找第i的元素,并返回该结点。DLNode * GetNode(DLinkList L,int i){    DLinkList temp = L;    while(i > 0 && temp){        i--;        temp = temp->next;    }    return temp;}//打印链表void PrintList(DLinkList L){    DLinkList temp = L->next;    while(temp){        cout<< temp->elem;        temp=temp->next;    }    cout<< endl;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> data_structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LinkList</title>
      <link href="posts/linklist.html"/>
      <url>posts/linklist.html</url>
      
        <content type="html"><![CDATA[<h1 id="链表的定义"><a href="#链表的定义" class="headerlink" title="链表的定义"></a>链表的定义</h1><h2 id="单链表结点描述"><a href="#单链表结点描述" class="headerlink" title="单链表结点描述"></a>单链表结点描述</h2><pre class=" language-c++"><code class="language-c++">#define datatype int        //定义默认数据类型 typedef struct node{        //定义单链表结点类型    datatype elem;            //数据域    struct node *next;        //指针域}LNode,*LinkList;</code></pre><p>强调这是一个单链表——使用Linklist，如函数传递参数<br>强调这是一个结点——使用LNode *，如函数返回一个结点</p><p>eg:    LNode * ListFind(LinkList L,datatype i)</p><h1 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h1><pre class=" language-markdown"><code class="language-markdown">ADT List{<span class="token code keyword">    数据对象:    D = {a_i|a_i∈Elemset,i=1,2,...n,n≥0}</span><span class="token code keyword">    数据关系:    R_1 = {&lt;a_{i-1},a_i>|a_{i-1},a_i∈D,i=1,2,...n,n≥0}</span><span class="token code keyword">    基本操作:</span><span class="token code keyword">        InitList(&amp;L);        //构造一个空的线性表L</span><span class="token code keyword">        DestroyList(&amp;L);    //销毁线性表L（线性表L已存在）</span><span class="token code keyword">        ClearList(&amp;L);        //将L重置为空表(线性表L已存在)</span><span class="token code keyword">        ListEmpty(L);        //若L为空表，则返回true，否则返回false</span><span class="token code keyword">        ListLength(L);        //返回L中数据元素个数</span><span class="token code keyword">        GetElem(L,i,&amp;e)        //用e返回L中第i个数据元素的值。</span><span class="token code keyword">        Listlnsert(&amp;L,i,Item);//在表L中的第i个位置后插入指定元素e</span><span class="token code keyword">        ListDelete(&amp;L,i);//删除表L中第i个位置后的元素 </span><span class="token code keyword">        GetNext(L,Item,&amp;p);    //在表L中查找具有给定关键字值的元素的下一位,并赋值给形参。</span><span class="token code keyword">        LocateElem(L,Item);    //在表L中查找具有给定关键字值的元素,成功返回下标。 </span><span class="token code keyword">        GetPrior(L,Item,&amp;p);//在表L中查找具有给定关键字值的元素的前一位,并赋值给形参。</span><span class="token code keyword">        PrintList(L);//按前后顺序输出线性表L的所有元素值 </span>}ADT List</code></pre><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><strong>不带头结点的初始化</strong></p><pre class=" language-c++"><code class="language-c++">//初始化一个空的单链表bool InitList(LinkList &L){    L = NULL；//空表，暂时还没有任何结点    return true;}...LinkList L;        //声明一个指向单链表的指针InitList(L);    //初始化一个空表</code></pre><p>其中<code>bool InitList(LinkList &amp;L)</code>等价于<code>bool InitList(LNode *&amp;L)</code></p><p>理解 <code>&amp;*p</code>等于``*&amp;p`等于 p, 也就是 p 指向的 变量的地址</p><p><strong>带头结点的初始化</strong></p><pre class=" language-c++"><code class="language-c++">//初始化一个空的单链表bool InitList(LinkList &L){    L=(LNode*)malloc(sizeof(LNode));    //分配一个头结点    if(L==NULL)                            //内存不足，分配失败        return false;    L->next=NULL;                        //头结点之后暂时还没有节点    return true;}...LinkList L;        //声明一个指向单链表的指针InitList(L);    //初始化一个空表</code></pre><h1 id="带头结点单链表的实现"><a href="#带头结点单链表的实现" class="headerlink" title="带头结点单链表的实现"></a>带头结点单链表的实现</h1><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <cstdlib>#define datatype intusing namespace std;typedef struct node{    datatype elem;    struct node *next;}LNode,*LinkList;bool InitList(LinkList &L);                 //初始化一个空的单链表bool ListInsert(LinkList &L,int i,datatype e);//插入操作。在表L中的第i个位置上插入指定元素e。bool ListDelete(LinkList &L,int i,datatype &e);//删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值。LNode * GetNode(LinkList L,int i);          //查找第i个结点datatype GetElem(LinkList L,int i);             //按位查找操作。获取表L中第个位置的元素的值。LNode * LocateElem(LinkList L,datatype e);     //按值查找操作。在表L中查找具有给定关键字值的元素。int ListLength(LinkList L);                    //查询单链表表长，返回表长void print(LinkList L);                        //打印单链表void ListTailInsert(LinkList &L);            //尾插法，顺序。void ListHeadInsert(LinkList &L);            //头插法，倒序。int main(){    LinkList head;    int e;    InitList(head);    ListHeadInsert(head);        //ListTailInsert(head);    print(head);    ListInsert(head,2,3);    print(head);    ListDelete(head,3,e);    print(head);    cout<< GetElem(head,2)<< endl;    cout<< LocateElem(head,5)->elem<< endl;} //初始化一个空的单链表bool InitList(LinkList &L){    L=(LNode*)malloc(sizeof(LNode));    //分配一个头结点    if(L==NULL)                            //内存不足，分配失败        return false;    L->next=NULL;                        //头结点之后暂时还没有节点    return true;}//插入操作。在表L中的第i个位置上插入指定元素e。bool ListInsert(LinkList &L,int i,datatype e){    LinkList temp = GetNode(L,i-1);    LNode * s = (LinkList)malloc(sizeof(LNode));    s->elem = e;    s->next = temp->next;    temp->next = s;    return true;}//删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值。bool ListDelete(LinkList &L,int i,datatype &e){    LinkList temp = GetNode(L,i-1);    LNode *p = temp->next;    temp->next = p->next;    e = p->elem;    free(p);    return true;}//查找第i个结点LNode * GetNode(LinkList L,int i){    if(i<0||i>ListLength(L)){        return NULL;    }    LinkList temp = L;    int j = 0;    while(temp && j != i){        temp = temp->next;        j++;    }    return temp;}//按位查找操作。获取表L中第i个位置的元素的值。datatype GetElem(LinkList L,int i){    LinkList temp = GetNode(L,i);    return temp->elem;}//按值查找操作。在表L中查找具有给定关键字值的元素。LNode * LocateElem(LinkList L,datatype e){    LNode * temp = L;    while(temp&&temp->elem!=e)        temp = temp->next;    return temp;}//查询单链表表长，返回表长int ListLength(LinkList L){    LinkList temp = L->next;    int i = 0;    while(temp){        temp = temp->next;        i++;    }    return i;}//打印单链表void print(LinkList L){    LNode * temp = L->next;    while(temp){        cout<< temp->elem;        temp = temp->next;    }    cout<< endl;}//尾插法，顺序。void ListTailInsert(LinkList &L){    int elem;    cin>>elem;    LNode * r = L;        //设置一个尾指针，每次在尾指针后面插入    while(elem != -1){        LNode * temp = (LNode *)malloc(sizeof(LNode));        temp->elem = elem;        r->next = temp;        r = r->next;        cin>>elem;    }    r->next = NULL;}//头插法，倒序。void ListHeadInsert(LinkList &L){    int elem;    cin>>elem;    while(elem != -1){        LNode * temp = (LNode *)malloc(sizeof(LNode));        temp->elem = elem;        temp->next = L->next;        L->next = temp;        cin>>elem;    }}</code></pre><h1 id="不带头结点单链表的实现"><a href="#不带头结点单链表的实现" class="headerlink" title="不带头结点单链表的实现"></a>不带头结点单链表的实现</h1><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <cstdlib>#define datatype intusing namespace std;typedef struct node{    datatype elem;    struct node *next;}LNode,*LinkList;bool InitList(LinkList &L);                 //初始化一个空的单链表bool ListInsert(LinkList &L,int i,datatype e);//插入操作。在表L中的第i个位置上插入指定元素e。bool ListDelete(LinkList &L,int i,datatype &e);//删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值。LNode * GetNode(LinkList L,int i);          //查找第i个结点datatype GetElem(LinkList L,int i);             //按位查找操作。获取表L中第个位置的元素的值。LNode * LocateElem(LinkList L,datatype e);     //按值查找操作。在表L中查找具有给定关键字值的元素。int ListLength(LinkList L);                    //查询单链表表长，返回表长void print(LinkList L);                        //打印单链表void ListTailInsert(LinkList &L);            //尾插法，顺序。void ListHeadInsert(LinkList &L);            //头插法，倒序。int main(){    LinkList L;    int e;    InitList(L);    ListTailInsert(L);        //ListTailInsert(L);    print(L);    ListInsert(L,2,3);    print(L);    ListDelete(L,3,e);    print(L);    cout<< GetElem(L,2)<< endl;    cout<< LocateElem(L,5)->elem<< endl;} //初始化一个空的单链表bool InitList(LinkList &L){    L = NULL;                        return true;}//插入操作。在表L中的第i个位置上插入指定元素e。bool ListInsert(LinkList &L,int i,datatype e){    LinkList temp = GetNode(L,i-1);    if(!temp){        if(i == 1){            LNode * s = (LinkList)malloc(sizeof(LNode));            s->elem = e;            s->next = L;            L = s;            return true;        }        else            return false;    }    LNode * s = (LinkList)malloc(sizeof(LNode));    s->elem = e;    s->next = temp->next;    temp->next = s;    return true;}//删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值。bool ListDelete(LinkList &L,int i,datatype &e){    LinkList temp = GetNode(L,i-1);    if(!temp){        L=NULL;        return true;    }    LNode *p = temp->next;    temp->next = p->next;    e = p->elem;    free(p);    return true;}//查找第i个结点LNode * GetNode(LinkList L,int i){    if(i<1||i>ListLength(L)){        return NULL;    }    LinkList temp = L;    int j = 1;    while(temp && j != i){        temp = temp->next;        j++;    }    return temp;}//按位查找操作。获取表L中第i个位置的元素的值。datatype GetElem(LinkList L,int i){    LinkList temp = GetNode(L,i);    if(temp)    return temp->elem;}//按值查找操作。在表L中查找具有给定关键字值的元素。LNode * LocateElem(LinkList L,datatype e){    LNode * temp = L;    while(temp&&temp->elem!=e)        temp = temp->next;    return temp;}//查询单链表表长，返回表长int ListLength(LinkList L){    LinkList temp = L;    int i = 0;    while(temp){        temp = temp->next;        i++;    }    return i;}//打印单链表void print(LinkList L){    LNode * temp = L;    while(temp){        cout<< temp->elem;        temp = temp->next;    }    cout<< endl;}//尾插法，顺序。void ListTailInsert(LinkList &L){    int elem;    cin>>elem;    LNode * r = L;        //设置一个尾指针，每次在尾指针后面插入    if(elem!=-1){        LNode * temp = (LNode *)malloc(sizeof(LNode));        temp->elem = elem;        L=temp;         r=temp;        cin>>elem;        while(elem != -1){            LNode * temp = (LNode *)malloc(sizeof(LNode));            temp->elem = elem;            r->next = temp;            r = r->next;            cin>>elem;        }        r->next = NULL;    }}//头插法，倒序。void ListHeadInsert(LinkList &L){    int elem;    cin>>elem;    while(elem != -1){        LNode * temp = (LNode *)malloc(sizeof(LNode));        temp->elem = elem;        temp->next = L;        L = temp;        cin>>elem;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> data_structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++ 传递指针给函数</title>
      <link href="posts/cpp-passing-pointers-to-functions.html"/>
      <url>posts/cpp-passing-pointers-to-functions.html</url>
      
        <content type="html"><![CDATA[<h1 id="C-传递指针给函数"><a href="#C-传递指针给函数" class="headerlink" title="C++ 传递指针给函数"></a>C++ 传递指针给函数</h1><p>C++ 允许您传递指针给函数，只需要简单地声明函数参数(形参)为指针类型即可。</p><h2 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h2><p>typedef：给变量取一个易记且意义明确的新名字；简化一些比较复杂的类型声明。</p><p>typedef <u>①</u> <u>②</u>:给①起个叫②的别名；</p><pre class=" language-c++"><code class="language-c++">struct [结构体名(临时名字,可省略)]{    类型标识符    成员名；     ...     ...     ...}变量名/序列(新名字);</code></pre><pre class=" language-c++"><code class="language-c++">typedef struct node{    int data;    struct node *lchild;    struct node *rchild;}BTNode,* btnode;BTNode BT;    //①,BT是某个节点的名字BTNode *BT;    //②,BT是指针型变量btnode BT;    //③,BT是指针型变量BT = (BTNode *)malloc(sizeof(BTNode));    //分配空间</code></pre><p>其中②③等价；即(*BT)-&gt;data↔ BT-&gt;data ;</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><pre class=" language-c++"><code class="language-c++">#include<iostream>#include<cstdlib>#define maxsize 1024        //定义最大长度#define datatype int        //定义默认数据类型 using namespace std;typedef struct SquenList{        datatype elem[maxsize];    //用静态的"数组"存放数据元素        int length;                //顺序表的当前长度}SquenList, * sequenlist;    //顺序表的类型定义bool ChangeElem(sequenlist L,int i,datatype Item);    //L是SquenList类型的指针int main(){    datatype temp;    sequenlist s = (SquenList *)malloc(sizeof(SquenList));//声明一个指向顺序表的指针，并为顺序表分配空间        s->length = 6;    for(int i = 0;i<s->length;i++){            s->elem[i] = i;    //{[0],[1],[2],[3],[4],[5]}    }    ChangeElem(s,4,1);    //{[0],[1],[2],[3],[1],[5]};指针传递给函数时，形参传入的是地址;s表示指向顺序表的地址}bool ChangeElem(sequenlist L,int i,datatype Item){    if(i<0||i>L->length-1){        cout<<"err"<<endl;        return false;    }else {        L->elem[i] = Item;       return true;     }}</code></pre><p>形参定义为指针类型时，实参传递一定是地址。</p><pre class=" language-c++"><code class="language-c++">void func1(int *a);int main (){   int b;   func1( &b );   return 0;}</code></pre><pre class=" language-c++"><code class="language-c++">void func1(int *a);int main (){   int b[5]={1,2,3,4,5};   func1(b);   return 0;}</code></pre><p>数组变量名为首地址。</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 中指针和引用的区别</title>
      <link href="posts/cpp-difference-between-pointers-and-references.html"/>
      <url>posts/cpp-difference-between-pointers-and-references.html</url>
      
        <content type="html"><![CDATA[<h2 id="C-引用与指针的比较"><a href="#C-引用与指针的比较" class="headerlink" title="C++ 引用与指针的比较"></a>C++ 引用与指针的比较</h2><p>引用是 C++ 中的概念，初学者容易把引用和指针混淆一起。</p><p>引用是变量的别名，不会产生副本，和原变量是同一个东西，因此对引用变量的操作就是对原变量的操作。在底层，<strong>引用变量</strong>由<u>指针按照指针常量的方式实现</u>!</p><p>一下程序中，n 是m的一个引用（reference），m 是被引用物（referent）。</p><pre class=" language-c++"><code class="language-c++">int m; int &n = m; </code></pre><p>n 相当于 m 的别名（绰号），对 n 的任何操作就是对m的操作。</p><p>所以 n 既不是m的拷贝，也不是指向 m 的指针，其实n就是 m 它自己。</p><p>引用的规则：</p><ul><li>（1）引用被创建的同时必须被初始化（指针则可以在任何时候被初始化）。</li><li>（2）不能有 NULL 引用，引用必须与合法的存储单元关联（指针则可以是 NULL）。</li><li>（3）一旦引用被初始化，就不能改变引用的关系（指针则可以随时改变所指的对象）。</li></ul><p>以下示例程序中，k 被初始化为i的引用。</p><p>语句 k = j 并不能将 k 修改成为j的引用，只是把k的值改变成为 6。</p><p>由于 k 是 i 的引用，所以i的值也变成了 6。</p><pre class=" language-c++"><code class="language-c++">int i = 5; int j = 6; int &k = i; k = j; // k 和 i 的值都变成了 6;</code></pre><p>引用的主要功能是传递函数的参数和返回值。</p><p>C++ 语言中，函数的参数和返回值的传递方式有三种：值传递、指针传递和引用传递。</p><h2 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h2><p>由于 Func1 函数体内的 x 是外部变量 n 的一份拷贝,函数体内的 x有新的存储空间,改变 x 的值不会影响 n,函数执行完毕后x会被销毁， 所以 n 的值仍然是 0。</p><pre class=" language-c++"><code class="language-c++">void Func1(int x) {     x = x + 10; } ... int n = 0; Func1(n); cout <<  "n = " <<  n <<  endl; // n = 0 </code></pre><h2 id="指针传递"><a href="#指针传递" class="headerlink" title="指针传递"></a>指针传递</h2><p>将指针作为函数参数，可以看作是将指针所指变量的<strong>地址</strong>传入函数，形参指针指向该地址，<strong>即两个指针指向同一地址</strong>；如果在函数中对这个地址中的元素进行改变，传入指针所指变量的数据就会确实的发生改变。</p><p>由于 Func2 函数体内的 x 是指向外部变量 n 的指针，* x表示取x中存储的地址的里面的值，即指针所指变量的值；改变该指针的内容将导致 n 的值改变，所以 n 的值成为 10。</p><pre class=" language-c++"><code class="language-c++">void Func2(int *x) {     (* x) = (* x) + 10; } ...int n = 0; Func2(&n); cout <<  "n = " <<  n <<  endl; // n = 10 </code></pre><p>但是如果在函数中改变的是指针指向的地址，则对传入的指针变量不会产生影响。</p><pre class=" language-c++"><code class="language-c++">int a = 10;        //全局变量void Func3(int *x) {     x = &a; } ...int n = 0;int *m = &nFunc3(m); cout <<  "n = " <<  *m <<  endl; // n = 0 </code></pre><p>改变指针变量指向的地址，相当于使指针x从指向实参n变成指向全局变量a，而形参值的改变不会影响实参的值，所以传入指针所指地址不会发生改变。</p><p>如果想要改变指针指向的地址，就需要在函数中传递指针的指针。</p><pre class=" language-c++"><code class="language-c++">int a = 10;        //全局变量void Func3(int **x) {     *x = &a; } ...int n = 0;int *m = &nFunc3(&m); cout <<  "n = "<< n<<  "*m = " <<  *m <<  endl; // n = 0 *m = 10</code></pre><h2 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h2><p>由于 Func3 函数体内的 x 是外部变量 n 的引用，x 和 n 是同一个东西，<strong>即一个地址两个名字</strong>；改变 x 等于改变 n，所以 n 的值成为 10。</p><pre class=" language-c++"><code class="language-c++">void Func3(int &x) {     x = x + 10; } ... int n = 0; Func3(n); cout <<  "n = " <<  n <<  endl; // n = 10</code></pre><p>有了引用之后，改变指针指向的地址就可以通过指针的引用来实现。</p><pre class=" language-c++"><code class="language-c++">int a = 10;        //全局变量void Func3(int *&x) {     *x = &a; } ...int n = 0;int *m = &nFunc3(m); cout <<  "n = "<< n<<  "*m = " <<  *m <<  endl; // n = 0 *m = 10</code></pre><p>对比上述三个示例程序，会发现”引用传递”的性质像”指针传递”，而书写方式像”值传递”。</p><p>实际上”引用”可以做的任何事情”指针”也都能够做，为什么还要”引用”这东西？</p><p>答案是”用适当的工具做恰如其分的工作”。</p><p>指针能够毫无约束地操作内存中的任何东西，尽管指针功能强大，但是非常危险。</p><p>如果的确只需要借用一下某个对象的”别名”，那么就用”引用”，而不要用”指针”，以免发生意外。</p><p><u>当用指针或者引用做形参来改变主函数中变量的值得时候，指针是值传递，传递的是指针变量的值；而引用是址传递，传递的是变量的地址。另外还有一点要知道，指针做形参，传递指针的时候，会产生一个临时的<strong>指针变量</strong>，需要分配额外的内存空间；但是传引用的话则不会，<strong>引用变量</strong>的地址由编译器掌握，程序员无法直接对它进行存取，对引用取地址&amp;，相当于取原变量的地址</u></p><h1 id="amp-p和-amp-p的理解"><a href="#amp-p和-amp-p的理解" class="headerlink" title="*&amp;p和&amp;*p的理解"></a>*&amp;p和&amp;*p的理解</h1><p>指针和地址其实是一个概念，但又有所区别。</p><p>*&amp;p=*q表示:指针变量p是q的引用</p><p>在存储中，每个存储单元就是一个格子。地址就是格子的编号，数据就是格子里面存放的内容。</p><p><strong>&amp;是取地址运算符</strong>，如有 int a; 即分配一个格子起名叫a，&amp;a就是取a的地址，即该盒子的编号。</p><p>*<strong>是取值运算符</strong>，<code>*(&amp;a) </code>就是打开a对应的格子，取出里面的数据，即<code>*(&amp;a)</code>和a等价。</p><p><code>int *p=&amp;a；</code>相当于<code>int *p; p=&amp;a;</code></p><p>p存放的是a的地址，*p也等价于 a。指针变量p既然是变量，也同变量a一样对应一个格子，也有一个地址编号，&amp;p就是取指针p的地址。这样就好理解二级指针了。</p><p><strong>*p和**p的区别</strong></p><p>int *p ：一级指针，表示p所指向的地址里面存放的是一个int类型的值</p><p>int **p ：二级指针，表示p所指向的地址里面存放的是一个指向int类型的指针（即p指向的地址里面存放的是一个指向int的一级指针）</p><p>例：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//定义整形变量</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//定义一个指针指向这个变量</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>p1<span class="token operator">=</span><span class="token operator">&amp;</span>p<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//定义一个二级指针指向p指针</span><span class="token comment" spellcheck="true">/*   那么取出5的方式都有哪些呢？ */</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a=%d"</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a=%d"</span><span class="token punctuation">,</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a=%d"</span><span class="token punctuation">,</span><span class="token operator">*</span><span class="token operator">*</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>以上3行输出的值都是5 。</p><h3 id="amp-p和-amp-p"><a href="#amp-p和-amp-p" class="headerlink" title="*&amp;p和&amp;*p"></a>*&amp;p和&amp;*p</h3><p>根据运算优先级，*&amp;p 等价于*(&amp;p)。&amp;*p 等价于&amp;(*p)。</p><p>如果p是int *指针变量，那么*&amp;p = p，&amp;*p = p，都是p.</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//定义整形变量</span><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//定义一个指针指向这个变量，即p=&amp;a</span><span class="token comment" spellcheck="true">//*&amp;p-->一个int指针的引用</span><span class="token comment" spellcheck="true">//&amp;*p-->*P等同于变量a;  所以&amp;(*p)就是&amp;a;</span></code></pre><p><strong>参考</strong></p><p>- <a href="https://www.runoob.com/w3cnote/cpp-difference-between-pointers-and-references.html">菜鸟教程</a></p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SequenceList</title>
      <link href="posts/sequencelist.html"/>
      <url>posts/sequencelist.html</url>
      
        <content type="html"><![CDATA[<h1 id="顺序表的定义"><a href="#顺序表的定义" class="headerlink" title="顺序表的定义"></a>顺序表的定义</h1><h2 id="静态分配存储"><a href="#静态分配存储" class="headerlink" title="静态分配存储"></a>静态分配存储</h2><pre class=" language-c++"><code class="language-c++">#define maxsize 1024        //定义最大长度#define datatype int        //定义默认数据类型 typedef struct SquenList{    datatype elem[maxsize];    //用静态的"数组"存放数据元素        int length;                //顺序表的当前长度}SquenList, *sequenlist;    //顺序表的类型定义SquenList S;                //声明一个顺序表S.length = 0;                //初始化</code></pre><h2 id="动态分配存储"><a href="#动态分配存储" class="headerlink" title="动态分配存储"></a>动态分配存储</h2><pre class=" language-c++"><code class="language-c++">#define InitSize 100        //顺序表的初始长度typedef struct SquenList{        datatype *elem;            //用静态的"数组"存放数据元素        int length,MaxSize;        //顺序表的当前长度和最大容量}SquenList, *sequenlist;    //顺序表的类型定义sequenlist S;                //声明一个顺序表S = (SquenList *)malloc(sizeof(SquenList)*InitSize);    //初始化S->length = 0;S->MaxSize = InitSize;</code></pre><p>malloc函数返回一个指针，需要强制转型为你定义的数据元素类型指针;</p><p>malloc函数的参数，指明要分配多大的连续内存空间;</p><p>指针同一维数组理解；</p><pre class=" language-c++"><code class="language-c++">int A[MaxSize];int n;</code></pre><p>答卷时，简洁定义。</p><h1 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h1><pre class=" language-markdown"><code class="language-markdown">ADT List{<span class="token code keyword">    数据对象:    D = {a_i|a_i∈Elemset,i=1,2,...n,n≥0}</span><span class="token code keyword">    数据关系:    R_1 = {&lt;a_{i-1},a_i>|a_{i-1},a_i∈D,i=1,2,...n,n≥0}</span><span class="token code keyword">    基本操作:</span><span class="token code keyword">        InitList(&amp;L);        //构造一个空的线性表L</span><span class="token code keyword">        DestroyList(&amp;L);    //销毁线性表L（线性表L已存在）</span><span class="token code keyword">        ClearList(&amp;L);        //将L重置为空表(线性表L已存在)</span><span class="token code keyword">        ListEmpty(L);        //若L为空表，则返回true，否则返回false</span><span class="token code keyword">        ListLength(L);        //返回L中数据元素个数</span><span class="token code keyword">        GetElem(L,i,&amp;e)        //用e返回L中第i个数据元素的值。</span><span class="token code keyword">        Listlnsert(&amp;L,i,Item);//在表L中的第i个位置后插入指定元素e</span><span class="token code keyword">        ListDelete(&amp;L,i);//删除表L中第i个位置后的元素 </span><span class="token code keyword">        GetNext(L,Item,&amp;p);    //在表L中查找具有给定关键字值的元素的下一位,并赋值给形参。</span><span class="token code keyword">        LocateElem(L,Item);    //在表L中查找具有给定关键字值的元素,成功返回下标。 </span><span class="token code keyword">        GetPrior(L,Item,&amp;p);//在表L中查找具有给定关键字值的元素的前一位,并赋值给形参。</span><span class="token code keyword">        PrintList(L);//按前后顺序输出线性表L的所有元素值 </span>}ADT List</code></pre><h1 id="顺序表的实现"><a href="#顺序表的实现" class="headerlink" title="顺序表的实现"></a>顺序表的实现</h1><pre class=" language-c++"><code class="language-c++">#include<iostream>#include<cstdlib>#define maxsize 1024        //定义最大长度#define datatype int        //定义默认数据类型 using namespace std;typedef struct SquenList{        datatype elem[maxsize];    //用静态的"数组"存放数据元素        int length;                //顺序表的当前长度}SquenList, *sequenlist;    //顺序表的类型定义void InitList(sequenlist L);                            //初始化表void DestroyList(sequenlist L);                            //销毁int ListLength(sequenlist L);                            //求表长void Listlnsert(sequenlist L,int i,datatype Item);        //在表L中的第i个位置后插入指定元素ebool ListDelete(sequenlist L,int i);                    //删除表L中第i个位置后的元素 bool GetNext(sequenlist L,datatype Item,datatype &p);    //在表L中查找具有给定关键字值的元素的下一位,并赋值给形参。datatype GetNode(sequenlist L,int i);                    //在表L中查找下标为i的元素,并返回元素的值。 int LocateElem(sequenlist L,datatype Item);                //在表L中查找具有给定关键字值的元素,成功返回下标。 bool GetPrior(sequenlist L,datatype Item,datatype &p);    //在表L中查找具有给定关键字值的元素的前一位,并赋值给形参。void PrintList(sequenlist L);                            //按前后顺序输出线性表L的所有元素值 void Empty(sequenlist L);                                //若L为空表，则返回true，否则返回falseint main(){    datatype temp;    sequenlist s = (SquenList *)malloc(sizeof(SquenList));//声明一个指向顺序表的指针，并为顺序表分配空间        InitList(s);    cin>>s->length;    for(int i = 0;i<s->length;i++){            cin>>s->elem[i];    }    Listlnsert(s,2,0);    PrintList(s);    cout<< "ListLength(s):"<< ListLength(s)<< endl;    cout<< "GetNode(s,2):"<< GetNode(s,2)<< endl;    cout<< "GetNext(s,2,&temp):"<< GetNext(s,2,temp)<< endl;    cout<< "temp:"<< temp<< endl;    cout<< "LocateElem(s,2):"<< LocateElem(s,2)<< endl;    cout<< "GetPrior(s,2,&temp):"<< GetPrior(s,2,temp)<< endl;    cout<< "temp:"<< temp<< endl;    cout<< "ListDelete(s,2):"<< ListDelete(s,2)<< endl;    PrintList(s);        cout<< "ListLength(s):"<< ListLength(s)<< endl;}void InitList(sequenlist L){        L->length = 0;}void DestroyList(sequenlist L){    L->length = 0;}int ListLength(sequenlist L){    return L->length;}void Listlnsert(sequenlist L,int i,datatype Item){    if(i<0||i>L->length||L->length==maxsize)        cout<< "err"<< endl;    else{        L->length++;        for(int j = L->length-1;j > i;j--){            L->elem[j] = L->elem[j-1];        }        L->elem[i] = Item;    }}bool ListDelete(sequenlist L,int i){    if(i<0||i>L->length-1||L->length==0)        return false;    else{        for(;i<L->length-1;i++)            L->elem[i] = L->elem[i+1];            L->length --;            return true;    }}bool GetNext(sequenlist L,datatype Item,datatype &p){    for(int i = 0 ; i < L->length-1; i++){        if(L->elem[i] == Item&&i+1<L->length){            p = L->elem[i+1];            cout<< p<< endl;            return true;        }    }    return false;}datatype GetNode(sequenlist L,int i){    if(i<0||i>L->length-1){        cout<< "err"<< endl;        return false;    }else return L->elem[i];}int LocateElem(sequenlist L,datatype Item){    for(int i = 0 ; i < L->length-1; i++){            if(L->elem[i] == Item){        return i;        }    else return 0;    }}bool GetPrior(sequenlist L,datatype Item,datatype &p){    for(int i = 0 ; i < L->length-1; i++){        if(L->elem[i] == Item&&i-1>=0){            p = L->elem[i-1];            cout<< p<< endl;            return true;        }    }    return false;}void PrintList(sequenlist L){    for(int i = 0;i<L->length;i++){        cout<< L->elem[i]<< " ";    }    cout<< endl;}</code></pre><p>由于形参指针没有赋予新值，可以理解为实参的引用！</p><h1 id="顺序表的特点"><a href="#顺序表的特点" class="headerlink" title="顺序表的特点"></a>顺序表的特点</h1><p>①随机访问，即可以在O(1)时间内找到第i个元素。<br>②存储密度高，每个节意只存储数据元素<br>③拓展容量不方便（即便采用动态分配的方式实现，拓展长度的时间复杂度也比较高）<br>④插入、删除操作不方便，需要移动大量元素</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> data_structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Target</title>
      <link href="posts/52273.html"/>
      <url>posts/52273.html</url>
      
        <content type="html"><![CDATA[<h1 id="考研的你必须知道的时间点"><a href="#考研的你必须知道的时间点" class="headerlink" title="考研的你必须知道的时间点"></a><strong>考研的你必须知道的时间点</strong></h1><h2 id="3-4月：协调时间、确定专业、基础复习"><a href="#3-4月：协调时间、确定专业、基础复习" class="headerlink" title="3-4月：协调时间、确定专业、基础复习"></a><strong>3-4月：协调时间、确定专业、基础复习</strong></h2><p>★对准备考研的同学来说，如果是在校大学生，就要<strong>处理好日常上课和研考复习的关系</strong>；如果是在职考生，则要<strong>处理好工作和复习备考的关系</strong>。</p><p>正就读大三的你们面临的压力并不小，因为既要完成学业，也要抽时间系统备考。这个时候_<strong>要全面了解院校和专业信息，初步确定研考目标</strong>_，院校、专业选择是考研的关键一步。提早确定专业方向和院校，会使专业课复习更有针对性。<u>可结合自身实际情况，综合考虑拟报考学校所在城市、专业发展、师资情况、就业前景等因素</u>。</p><p>★_<strong>3-4月务必开始第一轮基础复习</strong>_。在这个阶段需要打牢专业课和英语基础，求全面求细致。在这个期间过一遍专业课书籍、一遍英语单词，应该是没问题的。</p><h2 id="5-6月：一轮复习、夯实基础"><a href="#5-6月：一轮复习、夯实基础" class="headerlink" title="5-6月：一轮复习、夯实基础"></a><strong>5-6月：一轮复习、夯实基础</strong></h2><p>★_<strong>5月，同学们要全面开始第一轮研考复习</strong>_。<strong>要夯实基础，扎扎实实看一遍书，不要急于做模拟题</strong>。对政治、英语、数学三个公共课科目要细致备考。</p><p>对英语，要注重积累英语词汇，提升英语综合能力。对政治不能放松备考，要不断温故知新，也要及时补充和更新知识。对数学，要多练多算，总结答题规律。</p><p>对专业课的复习，要紧跟目标院校的专业课方向，有针对性地收集复习资料，包括往年专业课试题和老师的讲义、论文、专著等。部分学校还会发布当年的考试备考大纲，大家也可及时关注，也可登录相关院校网站查找上年度备考书目，或向在读研究生借阅备考资料。要在前期占有资料的基础上总结形成自己的笔记，构建专业课复习的知识框架。</p><p>★_<strong>6月，同学们要兼顾期末考试和研考复习的时间安排</strong>_。跨专业考研的同学不要因为研考复习而忽略本科专业期末考试的准备。还可以在6月初步制订一份暑假备考计划，考虑是自主复习还是报辅导班，是在校复习还是回家备考，复习时间如何安排等。</p><h2 id="7-8月：强化阶段，关键时期！"><a href="#7-8月：强化阶段，关键时期！" class="headerlink" title="7-8月：强化阶段，关键时期！"></a><strong>7-8月：强化阶段，关键时期！</strong></h2><p><strong>暑假是大家的强化复习阶段，这段时间也是提高专业课成绩的好时机！大家要根据自身情况制订复习计划并严格执行，通过专项突破弥补弱项。</strong></p><p>这个时候注意_<strong>制订复习计划要尽量细致</strong><em>，但也不能难以完成，要让自己每天都有成就感。可以尝试将复习内容分为多个阶段性小目标并限时完成，让复习更有计划性，且容易落实。</em><strong>暑期是提升薄弱科目的好时机，要多安排时间复习薄弱科目，尤其要进行专项突破</strong>_。</p><p>★这段时间，<strong>英语单词绝对不能落下</strong>，要坚持每天回顾，<strong>同时也要开始英语阅读的训练</strong>，每天不用多，精读2-3篇，但是要做到每一篇认真阅读，做完之后认真总结。</p><p>★<strong>数学要真正开始进行强化学习基础阶段，</strong>学过的所有知识，尽管可能刚开始的时候有困难，学起来很吃力，但是熬过这个阶段，就会豁然开朗。</p><p>★<strong>政治复习暑期最晚也要开启了</strong>，每天听几节课，<strong>假期结束最好听完强化班，搞定政治的基础内容</strong>。</p><p>★<strong>专业课可以针对资料的基础、大纲部分进行相关学习了</strong>，最低标准是到假期结束，你专业课能达到期末考试的水平。</p><h2 id="9-11月：了解政策并报名，第三轮复习"><a href="#9-11月：了解政策并报名，第三轮复习" class="headerlink" title="9-11月：了解政策并报名，第三轮复习"></a><strong>9-11月：了解政策并报名，第三轮复习</strong></h2><p>★9月，<strong>考研**</strong>政治、英语、数学大纲会相继发布。各学校的招生简章、专业目录和招生计划等也会陆续出台**。</p><p>在这个阶段，大家不仅要继续完成复习任务，还要注意最新研招政策、公共课大纲，也要留意院校网站公布的研招信息。还要注意<strong>预报名</strong>时间，按时登录中国研究生招生信息网进行预报名。</p><p>★10月，报名搞定后，这段时间的<strong>重点就是第三轮的复习</strong>，对知识点查缺补漏，并估算答题时间，争取在正式考试时能更合理地分配时间。</p><p>★11月，需要进入<strong>冲刺阶段</strong>，对真题开始进行全方位吃透，近十年的真题一定要认真完成，<strong>专业课和政治的学习占比要不断扩大</strong>。</p><p>距离考试越来越近，这个时候一定要注意调整心态，坚定复习信心。</p><h2 id="12月：最后冲刺"><a href="#12月：最后冲刺" class="headerlink" title="12月：最后冲刺"></a><strong>12月：最后冲刺</strong></h2><p>到了十二月，最后的<strong>冲刺阶段</strong>。这一阶段需要做到以下几点：</p><p>★<strong>认真梳理、有效整合各门课的知识</strong>，在头脑中形成对整个章节的知识框架图，做到基础知识烂熟于心；</p><p>★开始<strong>进行考场模拟训练</strong>，在考研的考试时间内，上午做政治或数学，下午做英语，把思维的活跃度训练在各科的考试时间；</p><p>★<strong>对重点和高频考点的知识进行每天的强化背诵</strong>，避免考试紧张大脑瞬间空白；</p><p>★政治一定要<strong>开始最后的押题背诵</strong>，每天保持一定量的记忆，进行知识积累，<strong>这个放心，到时候我会全程和你们在一起。</strong></p><p>★12月中旬，大家就可以凭着网报用户名和密码登录研招网<strong>下载打印准考证</strong>啦！大家这个时候要调整心态，不要因焦虑、恐慌等情绪而轻言放弃考试；也不要熬夜，可按照考试时间提前调整好作息和饮食！</p><h2 id="1-4月：准备复试、调剂"><a href="#1-4月：准备复试、调剂" class="headerlink" title="1-4月：准备复试、调剂"></a><strong>1-4月：准备复试、调剂</strong></h2><p>考研初试并非整个考研流程的结束，不要以为考试正式结束啦！</p><p><strong>初试结束以后，要根据答题情况立刻着手复试和调剂准备，搜集信息并进行有针对性的专业课复习，以便顺利通过复试</strong>。</p><p>另外，大家还要提前详细了解往年调剂流程、注意事项等，及时获取各个研招单位的调剂信息，积极主动联系需要调剂的研招单位，争取最有利的调剂结果！</p><p>22考研的同学们现在就可以有意识地学习学长学姐们的操作啦！到时候不至于过于慌乱不是？</p><p><strong>参考</strong></p><ul><li><a href="https://mp.weixin.qq.com/s/i0OADdO4hMFlZcEdEmE5Tw">考研政治徐涛</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Schedule </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown基本要素</title>
      <link href="posts/3.html"/>
      <url>posts/3.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-Markdown"><a href="#什么是-Markdown" class="headerlink" title="什么是 Markdown?"></a>什么是 Markdown?</h2><p><code>Markdown</code> 是一种文本格式。你可以用它来控制文档的显示。使用 markdown，你可以创建粗体的文字，斜体的文字，添加图片，并且创建列表 等等。基本上来讲，Markdown 就是普通的文字加上 <code>#</code> 或者 <code>*</code> 等符号。</p><h2 id="语法说明"><a href="#语法说明" class="headerlink" title="语法说明"></a>语法说明</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><blockquote><p><code>#</code> 这是 <code>&lt;h1&gt;</code>一级标题</p><p><code>##</code> 这是 <code>&lt;h2&gt;</code> 二级标题</p><p> <code>###</code>这是 <code>&lt;h3&gt;</code> 三级标题</p><p><code>####</code> 这是 <code>&lt;h4&gt;</code> 四级标题</p><p><code>#####</code> 这是 <code>&lt;h5&gt;</code> 五级标题</p><p><code>######</code> 这是 <code>&lt;h6&gt;</code> 六级标题</p></blockquote><p>如果你想要给你的标题加<code>id</code>或者<code>class</code>，请在标题最后添加<code>{#id .class1 .class2}</code>。例如：</p><blockquote><p><code>#</code> 这个标题拥有 1 个 id {`#my_id}</p><p><code>#</code> 这个标题拥有 2 个 classes {.class1 .class2}</p></blockquote><blockquote><p>这是一个 MPE扩展特性。</p></blockquote><h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><blockquote><p><code>*</code>这会是 <em>斜体</em>  的文字<code>*</code></p><p><code>_</code>这会是  <em>斜体</em>  的文字<code>_</code></p><p><code>**</code>这会是 <strong>粗体</strong> 的文字<code>**</code> </p><p><code>__</code>这会是 <strong>粗体</strong> 的文字<code>__</code> </p><p><code>_</code><em>你也 <code>**</code><strong>组合</strong><code>** </code> 这些符号</em><code>_</code></p><p><code>~~</code><del>这个文字将会被横线删除</del><code>~~</code></p></blockquote><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><blockquote><p><code>-</code> Item 1</p><p><code>-</code> Item 2</p><p>​    <code>-</code> Item 2a</p><p>​    <code>-</code> Item 2b</p></blockquote><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><pre class=" language-markdown"><code class="language-markdown"> <span class="token list punctuation">1.</span>  Item 1 <span class="token list punctuation">2.</span>  Item 2 <span class="token list punctuation">3.</span>  Item 3<span class="token code keyword">    1.  Item 3a</span><span class="token code keyword">    1.  Item 3b</span></code></pre><h3 id="添加图片"><a href="#添加图片" class="headerlink" title="添加图片"></a>添加图片</h3><pre class=" language-markdown"><code class="language-markdown">！<span class="token url">[github logo](/ijmages/logo.png)</span>Foramt: <span class="token url">![Alt Text](url)</span></code></pre><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><pre class=" language-markdown"><code class="language-markdown">https://github.com - 自动生成！<span class="token url">[GitHub](https://github.com)</span></code></pre><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><pre class=" language-markdown"><code class="language-markdown">正如 Kanye West 所说：<span class="token blockquote punctuation">></span> We're living the future so<span class="token blockquote punctuation">></span> the present is our past.</code></pre><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><pre class=" language-markdown"><code class="language-markdown">如下，三个或者更多的<span class="token hr punctuation">---</span>连字符<span class="token hr punctuation">---</span>星号<span class="token hr punctuation">---</span>下划线</code></pre><h3 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h3><pre class=" language-markdown"><code class="language-markdown">我觉得你应该在这里使用<span class="token code keyword">`&lt;addr>`</span> 才对。</code></pre><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><pre class=" language-markdown"><code class="language-markdown">你可以在你的代码上面和下面添加 ``` 来表示代码块。</code></pre><h4 id="语法高亮"><a href="#语法高亮" class="headerlink" title="语法高亮"></a>语法高亮</h4><p>你可以给你的代码块添加任何一种语言的语法高亮</p><p>例如，给 ruby 代码添加语法高亮：</p><pre class=" language-markdown"><code class="language-markdown">​```rubyrequire 'redcarpet'markdown = Redcarpet.new("Hello World!")puts markdown.to_html​```</code></pre><p>会得到下面的效果：</p><pre class=" language-ruby"><code class="language-ruby"><span class="token keyword">require</span> <span class="token string">'redcarpet'</span> markdown <span class="token operator">=</span> <span class="token constant">Redcarpet</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span> puts markdown<span class="token punctuation">.</span>to_html</code></pre><h4 id="代码块class-MPE扩展的特性"><a href="#代码块class-MPE扩展的特性" class="headerlink" title="代码块class(MPE扩展的特性)"></a>代码块class(MPE扩展的特性)</h4><p>你可以给你的代码块设置 <code>class</code>。</p><p>例如，添加 <code>class1 class2</code> 到一个 代码块：</p><pre class=" language-markdown"><code class="language-markdown">​```javascript {.class1 .class}function add(x, y) {  return x + y}​```</code></pre><h4 id="代码行数"><a href="#代码行数" class="headerlink" title="代码行数"></a>代码行数</h4><p>如果你想要你的代码块显示代码行数，只要添加 <code>line-numbers</code> class 就可以了。</p><p>例如：</p><pre class=" language-markdown"><code class="language-markdown">​```javascript {.line-numbers}function add(x, y) {  return x + y}​```</code></pre><p>将会得到下面的显示效果：</p><p><img src="../../medias/images/3-1.png" alt="配图 3-1"></p><h4 id="高亮代码行数"><a href="#高亮代码行数" class="headerlink" title="高亮代码行数"></a>高亮代码行数</h4><p>你可以通过添加 <code>highlight</code> 属性的方式来高亮代码行数：</p><pre class=" language-markdown"><code class="language-markdown">​```javascript {highlight=10}​```​```javascript {highlight=10-20}​```​```javascript {highlight=[1-10,15,20-22]}​```</code></pre><h3 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h3><pre class=" language-markdown"><code class="language-markdown"><span class="token list punctuation">-</span> [x] @mentions, #refs, [links](), <span class="token bold"><span class="token punctuation">**</span>formatting<span class="token punctuation">**</span></span>, and <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>del</span><span class="token punctuation">></span></span>tags<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>del</span><span class="token punctuation">></span></span> supported<span class="token list punctuation">-</span> [x] list syntax required (any unordered or ordered list supported)<span class="token list punctuation">-</span> [x] this is a complete item<span class="token list punctuation">-</span> [ ] this is an incomplete item</code></pre><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><pre class=" language-markdown"><code class="language-markdown"><span class="token title important">First Header | Second Header<span class="token punctuation">------------</span></span> | -------------Content from cell 1 | Content from cell 2Content in the first column | Content in the second column</code></pre><h2 id="扩展的语法"><a href="#扩展的语法" class="headerlink" title="扩展的语法"></a>扩展的语法</h2><h3 id="表格-1"><a href="#表格-1" class="headerlink" title="表格"></a>表格</h3><blockquote><p>需要在插件设置中打开 <code>enableExtendedTableSyntax</code> 选项来使其工作。</p></blockquote><p><img src="../../medias/images/3-2.png" alt="配图 3-2"></p><h3 id="Emoji-amp-Font-Awesome"><a href="#Emoji-amp-Font-Awesome" class="headerlink" title="Emoji &amp; Font-Awesome"></a>Emoji &amp; Font-Awesome</h3><blockquote><p>只适用于 <code>markdown-it parser</code> 而不适用于 <code>pandoc parser</code>。<br>缺省下是启用的。你可以在插件设置里禁用此功能。</p></blockquote><pre><code>:smile::fa-car:</code></pre><h3 id="上标"><a href="#上标" class="headerlink" title="上标"></a>上标</h3><pre class=" language-markdown"><code class="language-markdown">30^th^</code></pre><h3 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h3><pre class=" language-markdown"><code class="language-markdown">H~2~O</code></pre><h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><pre class=" language-markdown"><code class="language-markdown">Content [^1]<span class="token url-reference url"><span class="token punctuation">[</span><span class="token variable">^1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> Hi!</span> This is a footnote</code></pre><h3 id="缩略"><a href="#缩略" class="headerlink" title="缩略"></a>缩略</h3><pre class=" language-markdown"><code class="language-markdown">_<span class="token url-reference url"><span class="token punctuation">[</span><span class="token variable">HTML</span><span class="token punctuation">]</span><span class="token punctuation">:</span> Hyper</span> Text Markup Language_<span class="token url-reference url"><span class="token punctuation">[</span><span class="token variable">W3C</span><span class="token punctuation">]</span><span class="token punctuation">:</span> World</span> Wide Web ConsortiumThe HTML specificationis maintained by the W3C.</code></pre><h3 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h3><pre class=" language-markdown"><code class="language-markdown">==marked==</code></pre><h3 id="CriticMarkup"><a href="#CriticMarkup" class="headerlink" title="CriticMarkup"></a>CriticMarkup</h3><p>CriticMarkup 缺省是禁用的，你可以通过插件设置来启动它。<br>有关 CriticMarkup 的更多信息，请查看 <a href="https://criticmarkup.com/users-guide.php">CriticMarkup 用户指南</a>.</p><p>这里有 5 种基本语法：</p><pre><code>添加 {++ ++}删除 {-- --}替换 {~~ ~&gt; ~~}注释 {&gt;&gt; &lt;&lt;}高亮 {== ==}{&gt;&gt; &lt;&lt;}</code></pre><blockquote><p>CriticMarkup 仅可用于 markdown-it parser，不与 pandoc parser 兼容。</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://guides.github.com/features/mastering-markdown/">Mastering Markdown</a></li><li><a href="https://daringfireball.net/projects/markdown/basics">Daring Fireball: Markdown Basics</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.1.1操作系统的基本概念</title>
      <link href="posts/2.html"/>
      <url>posts/2.html</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统的基本概念"><a href="#操作系统的基本概念" class="headerlink" title="操作系统的基本概念"></a>操作系统的基本概念</h1><h2 id="概念-定义"><a href="#概念-定义" class="headerlink" title="概念(定义)"></a>概念(定义)</h2><p><strong><em>操作系统（Operating System，OS）</em></strong> 是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调用计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的软件系统<br><img src="../../medias/images/1-1.png" alt="配图 1-1"></p><h2 id="功能和目标"><a href="#功能和目标" class="headerlink" title="功能和目标"></a>功能和目标</h2><h3 id="资源的管理者"><a href="#资源的管理者" class="headerlink" title="资源的管理者"></a>资源的管理者</h3><p>提供的功能</p><blockquote><ul><li>处理机管理</li><li>存储器管理</li><li>文件管理</li><li>设备管理</li></ul></blockquote><p>目标</p><blockquote><ul><li>安全、高效</li></ul></blockquote><p><img src="../../medias/images/1-2.png" alt="配图 1-2"></p><h3 id="向用户提供服务（作为用户和计算机硬件之间的接口）"><a href="#向用户提供服务（作为用户和计算机硬件之间的接口）" class="headerlink" title="向用户提供服务（作为用户和计算机硬件之间的接口）"></a>向用户提供服务（作为用户和计算机硬件之间的接口）</h3><ul><li><p>提供的功能（统称为“用户接口”）</p><ol><li>命令接口（允许用户直接使用）<br>联机命令接口（交互式命令接口）<br>用户说一句，系统做一句<br><img src="../../medias/images/1-3.png" alt="配图 1-3"><br>脱机命令接口（批处理命令接口）<br>用户说一堆，系统做一堆<br><img src="../../medias/images/1-4.png" alt="配图 1-4"></li><li>程序接口（允许用户通过程序间接使用）<br>由一组系统调用组成（程序接口=系统调用）<br>系统调用=系统调用命令=广义指令<br><img src="../../medias/images/1-5.png" alt="配图 1-4"></li><li>GUI（图形用户界面）</li></ol></li><li><p>目标<br>方便使用</p></li></ul><h3 id="对硬件机器的扩展"><a href="#对硬件机器的扩展" class="headerlink" title="对硬件机器的扩展"></a>对硬件机器的扩展</h3><ul><li>扩展能力<br><img src="../../medias/images/1-6.png" alt="配图 1-4"></li></ul>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown</title>
      <link href="posts/1.html"/>
      <url>posts/1.html</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h1><h1 id="我展示的是一级标题"><a href="#我展示的是一级标题" class="headerlink" title="我展示的是一级标题"></a>我展示的是一级标题</h1><h2 id="我展示的是二级标题"><a href="#我展示的是二级标题" class="headerlink" title="我展示的是二级标题"></a>我展示的是二级标题</h2><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p>Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。<br>比<br>如</p><h1 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h1><p><em>斜体文本</em><br><em>斜体文本</em><br><strong>粗体文本</strong><br><strong>粗体文本</strong><br><strong><em>粗斜体文本</em></strong><br><strong><em>粗斜体文本</em></strong></p><h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p><hr><hr><hr><hr><hr><h1 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h1><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下：<br>I can <del>‘t</del> do it</p><h1 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h1><p>下划线可以通过 HTML 的 &lt;u&gt; 标签来实现：</p><p><u>带下划线文本</u></p><h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><p>脚注是对文本的补充说明。</p><p>Markdown 脚注的格式如下:<br>[^要注明的文本]</p><p><a href="%E6%BC%86%E5%BD%B1%E5%BC%BA">^QYQ</a>你可以的，加油！</p><h1 id="Markdown-列表"><a href="#Markdown-列表" class="headerlink" title="Markdown 列表"></a>Markdown 列表</h1><p>Markdown 支持有序列表和无序列表。</p><p>无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容：</p><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><p>有序列表使用数字并加上 . 号来表示，如：</p><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol><p>列表嵌套<br>列表嵌套只需在子列表中的选项前面添加四个空格即可：</p><ol><li>第一项：<ul><li>第一项嵌套的第一个元素</li><li>第一项嵌套的第二个元素</li></ul></li><li>第二项：<ul><li>第二项嵌套的第一个元素</li><li>第二项嵌套的第二个元素</li></ul></li></ol><h1 id="Markdown-区块"><a href="#Markdown-区块" class="headerlink" title="Markdown 区块"></a>Markdown 区块</h1><p>Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号：</p><blockquote><p>区块引用<br>结果交给锦鲤，<br>你只管努力就行！</p></blockquote><p>另外区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推：</p><blockquote><p>最外层</p><blockquote><p>第一层嵌套</p><blockquote><p>第二层嵌套</p></blockquote></blockquote></blockquote><p>区块中使用列表<br>区块中使用列表实例如下：</p><blockquote><p>区块中使用列表</p><ol><li>第一项</li><li>第二项</li></ol><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></blockquote><p>列表中使用区块<br>如果要在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进。</p><p>列表中使用区块实例如下：</p><ul><li>第一项<blockquote><p>结果交给锦鲤，<br>你只管努力就行！</p></blockquote></li><li>第二项</li></ul><h1 id="Markdown-代码"><a href="#Markdown-代码" class="headerlink" title="Markdown 代码"></a>Markdown 代码</h1><p>如果是段落上的一个函数或片段的代码可以用反引号把它包起来（`），例如：</p><p><code>printf()</code> 函数</p><p>代码区块<br>代码区块使用 4 个空格或者一个制表符（Tab 键）。</p><p>实例如下：<br>    &lt;?php<br>    echo ‘luoluo’<br>    function test(){<br>        echo ‘test’;<br>    }<br>    &gt;</p><p>你也可以用 ``` 包裹一段代码，并指定一种语言（也可以不指定）：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">$</span><span class="token punctuation">(</span>document<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ready</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'RUNOOB'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h1 id="Markdown-链接"><a href="#Markdown-链接" class="headerlink" title="Markdown 链接"></a>Markdown 链接</h1><p>链接使用方法如下：</p><p><a href="%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80">链接名称</a></p><p>或者</p><p>&lt;链接地址&gt;<br>例如：</p><p>这是一个链接 <a href="https://www.runoob.com/">菜鸟教程</a></p><p>高级链接<br>我们可以通过变量来设置一个链接，变量赋值在文档末尾进行：</p><p>这个链接用 1 作为网址变量 <a href="http://www.google.com/">Google</a><br>这个链接用 runoob 作为网址变量 <a href="http://www.runoob.com/">Runoob</a><br>然后在文档的结尾为变量赋值（网址）</p><h1 id="Markdown-图片"><a href="#Markdown-图片" class="headerlink" title="Markdown 图片"></a>Markdown 图片</h1><p>  Markdown 图片语法格式如下：</p><p><img src="%E5%9B%BE%E7%89%87%E5%9C%B0%E5%9D%80" alt="alt 属性文本"></p><p><img src="%E5%9B%BE%E7%89%87%E5%9C%B0%E5%9D%80" alt="alt 属性文本" title="可选标题"><br>开头一个感叹号 !<br>接着一个方括号，里面放上图片的替代文字<br>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 属性的文字。<br>使用实例：</p><p><img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB 图标"></p><p><img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB 图标" title="RUNOOB"></p><p>当然，你也可以像网址那样对图片网址使用变量:</p><p>这个链接用 1 作为网址变量 <a href="http://www.google.com/">RUNOOB</a>.<br>然后在文档的结尾为变量赋值（网址）</p><h1 id="Markdown-表格"><a href="#Markdown-表格" class="headerlink" title="Markdown 表格"></a>Markdown 表格</h1><p>Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。</p><p>语法格式如下：</p><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table><p>对齐方式</p><p>我们可以设置表格的对齐方式：</p><p>-: 设置内容和标题栏居右对齐。<br>:- 设置内容和标题栏居左对齐。<br>:-: 设置内容和标题栏居中对齐。<br>实例如下：</p><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table><h1 id="Markdown-高级技巧"><a href="#Markdown-高级技巧" class="headerlink" title="Markdown 高级技巧"></a>Markdown 高级技巧</h1><p>支持的 HTML 元素<br>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。</p><p>目前支持的 HTML 元素有：<kbd> <b> <i> <em> <sup> <sub> <br>等 ，如：</sub></sup></em></i></b></kbd></p><b><i><em><p>使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑</p><p>转义<br>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：</p><p><strong>文本加粗</strong><br>** 正常显示星号 **</p><p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p><p>\   反斜线<br>`   反引号<br>*   星号<br>_   下划线<br>{}  花括号<br>[]  方括号<br>()  小括号<br>#   井字号<br>+   加号<br>-   减号<br>.   英文句点<br>!   感叹号</p><p>公式<br>当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：</p><p>$$<br>\mathbf{V}_1 \times \mathbf{V}_2 =  \begin{vmatrix}<br>\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \<br>\frac{\partial X}{\partial u} &amp;  \frac{\partial Y}{\partial u} &amp; 0 \<br>\frac{\partial X}{\partial v} &amp;  \frac{\partial Y}{\partial v} &amp; 0 \<br>\end{vmatrix}<br>${$tep1}{\style{visibility:hidden}{(x+1)(x+1)}}<br>$$</p></em></i></b>]]></content>
      
      
      
        <tags>
            
            <tag> md </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>command</title>
      <link href="posts/16107.html"/>
      <url>posts/16107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><pre class=" language-bash"><code class="language-bash">$ hexo clean <span class="token operator">&amp;&amp;</span> hexo g <span class="token operator">&amp;&amp;</span>hexo s$ hexo clean <span class="token operator">&amp;&amp;</span> hexo g <span class="token operator">&amp;&amp;</span>hexo d</code></pre>]]></content>
      
      
      <categories>
          
          <category> test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
