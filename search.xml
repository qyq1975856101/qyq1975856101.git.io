<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Tree</title>
      <link href="posts/tree.html"/>
      <url>posts/tree.html</url>
      
        <content type="html"><![CDATA[<p>抽象数据结构</p><pre class=" language-markdown"><code class="language-markdown">ADT BinaryTree{<span class="token code keyword">    数据对象D:D是具有相同特性的数据元素的集合。</span><span class="token code keyword">    数据关系R：</span><span class="token code keyword">        若D=Φ，则R=Φ，称BinaryTree为空二叉树；</span><span class="token code keyword">        若D≠Φ，则R={H}，H是如下二元关系：</span><span class="token code keyword">            （1）在D中存在唯一的称为根的数据元素root，它在关系H下无前驱；</span><span class="token code keyword">            （2）若D-{root}≠Φ，则存在D-{root}={D_l，D_r}，且D_l∩D_r=Φ；</span><span class="token code keyword">            （3）若D_l≠Φ，则D_l中存在唯一的元素x_l，&lt;root,x_l>∈H，且存在D_l上的关系H_l∈H;若D_r≠Φ，则D_r中存在唯一的元素x_r，&lt;root，x_r>∈H，且存在D_r上的关系H_r∈H；H={&lt;root,x_l>,&lt;root,x_r>，H_l,H_r}；</span><span class="token code keyword">            （4）(D_1,{H_l})是一棵符合本定义的二又树，称为根的左子树，(D_1,{H_r})是一棵符合本定义的二叉树，称为根的右子树。</span><span class="token code keyword">    基本操作P：</span><span class="token code keyword">        InitBiTree(&amp;T);</span><span class="token code keyword">            操作结果：构造空二叉树T。</span><span class="token code keyword">        DestroyBiTree(&amp;T);</span><span class="token code keyword">            初始条件：二叉树T存在。武跑国读干市</span><span class="token code keyword">            操作结果：销毁二叉树T。</span><span class="token code keyword">        CreateBiTree(&amp;T,definition);</span><span class="token code keyword">            初始条件：definition给出二又树T的定义。</span><span class="token code keyword">            操作结果：按definition构造二叉树T </span><span class="token code keyword">        ClearBiTree(&amp;T);</span><span class="token code keyword">            初始条件：二又树T存在。</span><span class="token code keyword">            操作结果：将二又树T清为空树。</span><span class="token code keyword">        BiTreeEmpty(T);</span><span class="token code keyword">            初始条件：二又树T存在。</span><span class="token code keyword">            操作结果：若T为空二又树，则返回TRUE，否则BALSE。</span><span class="token code keyword">        BiTreeDepth(T);</span><span class="token code keyword">            初始条件：二又树T存在。</span><span class="token code keyword">            操作结果：返回T的深度。</span><span class="token code keyword">        Root(T);</span><span class="token code keyword">            初始条件：二又树T存在。</span><span class="token code keyword">            操作结果：返回T的根。</span><span class="token code keyword">        value(T,e);</span><span class="token code keyword">            初始条件：二叉树T存在，e是T中某个结点。</span><span class="token code keyword">            操作结果：返回e的值。</span><span class="token code keyword">        Assign(T,&amp;e,value);</span><span class="token code keyword">            初始条件：二又树T存在，e是T中某个结点</span><span class="token code keyword">            操作结果：结点e赋值为value。</span><span class="token code keyword">        Parent(T,e);</span><span class="token code keyword">            初始条件：二又树T存在，e是T中某个结点。</span><span class="token code keyword">            操作结果：若e是T的非根结点，则返回它的双亲，否则返回“空”。</span><span class="token code keyword">        LeftChild(T,e);</span><span class="token code keyword">            初始条件：二又树T存在，e是T中某个结点。</span><span class="token code keyword">            操作结果：返回e的左孩子。若e无左孩子，则返回“空”。</span><span class="token code keyword">        RightChild(T,e);</span><span class="token code keyword">            初始条件：二又树T存在，e是T中某个结点。</span><span class="token code keyword">            操作结果：返回e的右孩子。若e无右孩子，则返回“空”。</span><span class="token code keyword">        LeftSibling(T,e);</span><span class="token code keyword">            初始条件：二叉树T存在，e是T中某个结点。</span><span class="token code keyword">            操作结果：返回e的左兄弟。若e是T的左孩子或无左兄弟，则返回“空”。</span><span class="token code keyword">        RightSibling(T,e);</span><span class="token code keyword">            初始条件：二叉树T存在，e是T中某个结点。</span><span class="token code keyword">            操作结果；返回e的右兄弟。若。是T的右孩子或无右兄弟，则返回“空”。</span><span class="token code keyword">        Insertchild(T,p,LR,c);</span><span class="token code keyword">            初始条件：二又树T存在，p指向T中某个结点，LR为0或1，非空二树c与T不相交且右子树为空。</span><span class="token code keyword">            操作结果：根据LR为0或1，插入c为T中p所指结点的左或右子树。p所指结点的原有左或右子树则成为c的右子树。</span><span class="token code keyword">        Deletechild(T,p,LR);</span><span class="token code keyword">            初始条件：二又树T存在，p指向T种某个结点，LR为0或1.</span><span class="token code keyword">            操作结果：根据LR为0或1，删除T中p所指结点的左或右子树</span><span class="token code keyword">        PreOrderTraverse(T,Visit());</span><span class="token code keyword">            初始条件：二叉树T存在，Visit是对结点操作的应用函数。</span><span class="token code keyword">            操作结果：先序遍历T，对每个结点调用函数Visit一次且仅一次。一旦visit（）失败，则操作失败。</span><span class="token code keyword">        InOrderTraverse(T,Visit());</span><span class="token code keyword">            初始条件：二叉树T存在，Visit是对结点操作的应用函数。</span><span class="token code keyword">            操作结果：中序遍历T，对每个结点调用函数Visit一次且仅一次。一旦visit（）失败，则操作失败。</span><span class="token code keyword">        PostOrderTraverse(T,Visit());</span><span class="token code keyword">            初始条件：二叉树T存在，Visit是对结点操作的应用函数。</span><span class="token code keyword">            操作结果：后序遍历T，对每个结点调用函数Visit一次且仅一次。一旦visit（）失败，则操作失败。</span><span class="token code keyword">        LevelOrderTraverse(T,Visit());</span><span class="token code keyword">            初始条件：二又树T存在，Visit是对结点操作的应用函数。</span><span class="token code keyword">            操作结果：层序遍历T，对每个结点调用函数Visit一次且仅一次。一旦visit（）失败，则操作失败。</span>}ADT BinaryTree</code></pre>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> data_structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String</title>
      <link href="posts/string.html"/>
      <url>posts/string.html</url>
      
        <content type="html"><![CDATA[<h1 id="串的定义"><a href="#串的定义" class="headerlink" title="串的定义"></a>串的定义</h1><h2 id="定长顺序存储"><a href="#定长顺序存储" class="headerlink" title="定长顺序存储"></a>定长顺序存储</h2><p>静态数组实现①</p><pre class=" language-c++"><code class="language-c++">#define MAXLEN 255    //预定义最大串长为255typedef struct {    char ch[MAXLEN];//每个分量存储一个字符    int length;        //串的实际长度}SString;</code></pre><pre class=" language-c++"><code class="language-c++">#define MAXSTRLEN 255    //预定义最大串长为255typedef unsigned char SString[MAXSTRLEN+1] //0好单元存放穿的长度</code></pre><h2 id="堆分配存储-动态数组实现"><a href="#堆分配存储-动态数组实现" class="headerlink" title="堆分配存储(动态数组实现)"></a>堆分配存储(动态数组实现)</h2><pre class=" language-c++"><code class="language-c++">typedef struct{    char *ch;        //按串长分配存储区，Ch指向串的基地址    int length;        //串的长度}HString;HString S;S.ch = (char *)malloc(sizeof(char)*MAXLEN);S.length = 0;</code></pre><h2 id="串的链式存储"><a href="#串的链式存储" class="headerlink" title="串的链式存储"></a>串的链式存储</h2><pre class=" language-c++"><code class="language-c++">typedef struct StringNode{    char ch;            //每个结点存1个字符    struct StingNode *next;}StringNode,*string;</code></pre><h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><pre class=" language-markdown"><code class="language-markdown">ADT String{<span class="token code keyword">    数据对象:    D = {a_i|a_i∈CharacterSet,i=1,2,...n,n≥0}</span><span class="token code keyword">    数据关系:    R_1 = {&lt;a_{i-1},a_i>|a_{i-1},a_i∈D,i=1,2,...n}</span><span class="token code keyword">    基本操作:</span><span class="token code keyword">        StrAssign(&amp;T,chars);        //chars是字符串常量/生成一个其值等于chars的串T</span><span class="token code keyword">        StrCopy(&amp;T,S);                //串S存在/由串S复制得串T</span><span class="token code keyword">        StrEmpty(S);                //串S存在/若S为空串，则返回TRUE，否则返回FALSE</span><span class="token code keyword">        StrCompare(S,T);            //串S,T存在/若S>T,则返回值>0;若S=T,则返回值=0;若S&lt;T,则返回值&lt;0.</span><span class="token code keyword">        StrLength(S);                //串S存在/返回S的元素个数，称为串的长度</span><span class="token code keyword">        ClearString(&amp;S);            //串S存在/将S清为空串</span><span class="token code keyword">        Concat(&amp;T,S1,S2);            //串S1,S2存在/用T返回由S1和S2联结而成的新串</span><span class="token code keyword">        SubString(&amp;Sub,S,pos,len);    //串S存在,1&lt;=pos&lt;=StrLength(S)且0&lt;=len&lt;=StrLength(S)-pos+1/用Sub返回串S的第pos个字符起长度为len的子串</span><span class="token code keyword">        Index(S,T,pos);                //串S,T存在,T是非空串,1&lt;=pos&lt;=StrLength(S)/r若主串S存在和串T值相同的子串，则返回它在主串S中第pos个字符之后第一次出现的位置;否则返回0</span><span class="token code keyword">        Replace(&amp;S,T,V);            //串S,T,V存在,T是非空串/用V替换主串S中出现的所有与T相等的不重叠的子串</span><span class="token code keyword">        StrInsert(&amp;S,pos,T);        //串S,T存在/1&lt;=pos&lt;=StrLength(S)+1/在串S的第pos个字符之前插入串T</span><span class="token code keyword">        StrDlete(&amp;S,pos,len);        //串S存在/1&lt;=pos&lt;=StrLength(S)+1/从串S中删除第pos个字符起长度为len的子串</span><span class="token code keyword">        DestoryString(&amp;S);            //串S存在/串S被撤销</span>}ADT String</code></pre><h1 id="队列的实现"><a href="#队列的实现" class="headerlink" title="队列的实现"></a>队列的实现</h1>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> data_structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>The application of the stack</title>
      <link href="posts/the-application-of-the-stack.html"/>
      <url>posts/the-application-of-the-stack.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> data_structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Queue</title>
      <link href="posts/queue.html"/>
      <url>posts/queue.html</url>
      
        <content type="html"><![CDATA[<h1 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h1><h2 id="队列结点描述"><a href="#队列结点描述" class="headerlink" title="队列结点描述"></a>队列结点描述</h2><pre class=" language-c++"><code class="language-c++">#define DataType int#define MaxSize 10typedef struct node{    DataType data[maxsize];    int front,rear;}Node,SqQueue;</code></pre><h2 id="链队结点"><a href="#链队结点" class="headerlink" title="链队结点"></a>链队结点</h2><pre class=" language-c++"><code class="language-c++">#define DataType inttypedef struct node{    DataType data;    struct node * next;}LNode,*LinkNode;typedef struct{    LinkNode *front,*rear;}LinkQueue;</code></pre><h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><pre class=" language-markdown"><code class="language-markdown">ADT Queue{<span class="token code keyword">    数据对象:    D = {a_i|a_i∈Elemset,i=1,2,...n,n≥0}</span><span class="token code keyword">    数据关系:    R_1 = {&lt;a_{i-1},a_i>|a_{i-1},a_i∈D,i=1,2,...n}</span><span class="token code keyword">    基本操作:</span><span class="token code keyword">        InitQueue(&amp;Q);        //构造一个空的队列Q</span><span class="token code keyword">        DestroyQueue(&amp;Q);    //销毁队列Q（队列Q已存在）</span><span class="token code keyword">        ClearQueue(&amp;Q);        //将Q清为空队列(队列Q已存在)</span><span class="token code keyword">        QueueEmpty(Q);        //若Q为空队列，则返回true，否则返回false（队列Q已存在）</span><span class="token code keyword">        QueueLength(Q);        //返回队列Q中元素个数，即队列的长度（队列Q已存在）</span><span class="token code keyword">        GetHead(Q,&amp;e);        //用e返回队头元素。（队列Q已存在）</span><span class="token code keyword">        EnQueue(&amp;Q,e);        //插入元素e为新的队尾元素（队列Q已存在）</span><span class="token code keyword">        DeQueue(&amp;Q,&amp;e);        //删除Q的队头元素，并用e返回其值。（队列Q已存在）</span><span class="token code keyword">        QueueTraverse(Q);    //按前后顺序输出队列Q的所有元素值（队列Q已存在）</span>}ADT List</code></pre><h1 id="队列的实现"><a href="#队列的实现" class="headerlink" title="队列的实现"></a>队列的实现</h1><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <cstdlib>#define maxsize 1024#define datatype intusing namespace std;typedef struct node{    datatype data[maxsize];    int front;    int rear;}Node,SqQueue;bool InitQueue(SqQueue &Q);            //构造一个空的队列Qbool DestroyQueue(SqQueue &Q);        //销毁队列Q（队列Q已存在）bool ClearQueue(SqQueue &Q);        //将Q清为空队列(队列Q已存在)bool QueueEmpty(SqQueue Q);            //若Q为空队列，则返回true，否则返回false（队列Q已存在）int QueueLength(SqQueue Q);        //返回队列Q中元素个数，即队列的长度（队列Q已存在）bool GetHead(SqQueue Q,datatype &e);//用e返回队头元素。（队列Q已存在）bool EnQueue(SqQueue &Q,datatype e);//插入元素e为新的队尾元素（队列Q已存在）bool DeQueue(SqQueue &Q,datatype &e);//删除Q的队头元素，并用e返回其值。（队列Q已存在）bool QueueTraverse(SqQueue Q);      //按前后顺序输出队列Q的所有元素值（队列Q已存在）int main(){    int data;    datatype x;    SqQueue q;    InitQueue(q);    cin>>data;    while(data !=-1){        EnQueue(q,data);        cin>>data;    }    QueueTraverse(q);    cout<<QueueLength(q)<<endl;    GetHead(q,x);    cout<<x<<endl;    DeQueue(q,x);    cout<<x<<endl;    QueueTraverse(q);    ClearQueue(q);    QueueTraverse(q);    return 0;}//构造一个空的队列Qbool InitQueue(SqQueue &Q){    Q.front = 0;    Q.rear = 0;    return true;}//将Q清为空队列(队列Q已存在)bool ClearQueue(SqQueue &Q){    Q.front = Q.rear = 0;    return true;}        //若Q为空队列，则返回true，否则返回false（队列Q已存在）bool QueueEmpty(SqQueue Q){    return(Q.front == Q.rear);}//返回队列Q中元素个数，即队列的长度（队列Q已存在）int QueueLength(SqQueue Q){    return (Q.rear-Q.front);}//用e返回队头元素。（队列Q已存在）bool GetHead(SqQueue Q,datatype &e){    if(!QueueEmpty(Q))return false;    e = Q.data[Q.front];    return true;}//插入元素e为新的队尾元素（队列Q已存在）bool EnQueue(SqQueue &Q,datatype e){    if(Q.rear == maxsize)return false;    Q.data[Q.rear] = e;    Q.rear++;}//删除Q的队头元素，并用e返回其值。（队列Q已存在）bool DeQueue(SqQueue &Q,datatype &e){    if(!QueueEmpty(Q))return false;    e = Q.data[Q.front];    Q.front++;}//按前后顺序输出队列Q的所有元素值（队列Q已存在）bool QueueTraverse(SqQueue Q){    if(!QueueEmpty(Q))return false;    for(int i = Q.front; i<Q.rear;i++){        cout<<Q.data[i];    }    cout<<endl;}</code></pre><p>循环队列是改进的顺序队列</p><p><strong>循环队列</strong>牺牲一个存储单元来<strong>区别队空和队满</strong>！</p><table><thead><tr><th align="center">区别</th><th align="center">顺序队列</th><th align="center">循环队列</th></tr></thead><tbody><tr><td align="center">队空</td><td align="center">front = rear</td><td align="center">front = rear</td></tr><tr><td align="center">队满</td><td align="center">rear = MaxSize</td><td align="center">（rear+1）%MaxSize = front</td></tr><tr><td align="center">入队</td><td align="center">rear++</td><td align="center">rear=（rear+1）%MaxSize</td></tr><tr><td align="center">出队</td><td align="center">front++</td><td align="center">front=（front+1）%MaxSize</td></tr><tr><td align="center">元素个数</td><td align="center">rear-front</td><td align="center">(rear-front+MaxSize)%MaxSize</td></tr></tbody></table><p>要求循环队列不能牺牲一个存储单元来区别队空和队满</p><p>①在结构体里直接加size记录队列元素个数</p><p>②在结构体里加入一个tag（每次删除操作成功时，都令tag=0；每次插入操作成功时，都令tag=1；）</p><p>判空：front = rear&amp;&amp;tag=0（只有删除操作，才可能导致队空）</p><p>队满：front = rear&amp;&amp;tag=1（只有插入操作，才可能导致队满）</p><h1 id="链队的实现"><a href="#链队的实现" class="headerlink" title="链队的实现"></a>链队的实现</h1><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <cstdlib>#define MaxSize 1024#define DataType intusing namespace std;typedef struct node{    DataType data;    struct node * next;}LNode,*LinkNode;typedef struct link{    LinkNode front,rear;}LinkQueue;bool InitQueue(LinkQueue &Q);            //构造一个空的队列Qbool DestroyQueue(LinkQueue &Q);        //销毁队列Q（队列Q已存在）bool ClearQueue(LinkQueue &Q);        //将Q清为空队列(队列Q已存在)bool QueueEmpty(LinkQueue Q);            //若Q为空队列，则返回true，否则返回false（队列Q已存在）int QueueLength(LinkQueue Q);        //返回队列Q中元素个数，即队列的长度（队列Q已存在）bool GetHead(LinkQueue Q,DataType &e);//用e返回队头元素。（队列Q已存在）bool EnQueue(LinkQueue &Q,DataType e);//插入元素e为新的队尾元素（队列Q已存在）bool DeQueue(LinkQueue &Q,DataType &e);//删除Q的队头元素，并用e返回其值。（队列Q已存在）bool QueueTraverse(LinkQueue Q);      //按前后顺序输出队列Q的所有元素值（队列Q已存在）int main(){    int n;    LinkQueue Q;    InitQueue(Q);    cin>>n;    while(n!=-1){        EnQueue(Q,n);        cin>>n;    }    cout<<QueueLength(Q)<<endl;    DeQueue(Q,n);    cout<<n<<endl;    GetHead(Q,n);    cout<<n<<endl;    QueueTraverse(Q);    cout<<QueueLength(Q)<<endl;    return 0;}//构造一个空的队列Q(带头结点)bool InitQueue(LinkQueue &Q){    Q.front=Q.rear=(LinkNode)malloc(sizeof(LNode));    Q.front->next = NULL;}//销毁队列Q（队列Q已存在）bool DestroyQueue(LinkQueue &Q){    free(Q.front);    free(Q.rear);}//将Q清为空队列(队列Q已存在)bool ClearQueue(LinkQueue &Q){    Q.front->next = NULL;    Q.rear = Q.front;}//若Q为空队列，则返回true，否则返回false（队列Q已存在）bool QueueEmpty(LinkQueue Q){    return (Q.front=Q.rear);}//返回队列Q中元素个数，即队列的长度（队列Q已存在）int QueueLength(LinkQueue Q){    int i = 0;    LinkNode temp = Q.front->next;    while(temp){        i++;        temp = temp->next;    }    return i;}//用e返回队头元素。（队列Q已存在）bool GetHead(LinkQueue Q,DataType &e){    if(Q.front == Q.rear) return false;    e = Q.front->next->data;    return true;}//插入元素e为新的队尾元素（队列Q已存在）bool EnQueue(LinkQueue &Q,DataType e){    LinkNode temp = (LinkNode)malloc(sizeof(LNode));    if(!temp)return false;    temp->data = e;    temp->next = NULL;    Q.rear->next = temp;    Q.rear = temp;    return true;}//删除Q的队头元素，并用e返回其值。（队列Q已存在）bool DeQueue(LinkQueue &Q,DataType &e){    if(Q.front == Q.rear)return false;    LinkNode temp = Q.front->next;    e = temp->data;    Q.front->next = temp->next;    if(temp == Q.rear)        Q.rear = Q.front;    free(temp);    return true;}//按前后顺序输出队列Q的所有元素值（队列Q已存在）bool QueueTraverse(LinkQueue Q){    if(Q.front == Q.rear) return false;    LinkNode temp = Q.front->next;    while(temp){        cout<<temp->data;        temp = temp->next;    }    cout<<endl;    return true;}// //(不带头结点)// //构造一个空的队列Q// bool InitQueue(LinkQueue &Q){//     Q = (LinkQueue )malloc(sizeof(LinkQueue));//     Q->front= NULL;//     Q->rear= NULL;// }// //销毁队列Q（队列Q已存在）// bool DestroyQueue(LinkQueue &Q){//     free(Q);// }// //将Q清为空队列(队列Q已存在)// bool ClearQueue(LinkQueue &Q){//     Q->front = NULL;//     Q->rear = NULL;// }// //若Q为空队列，则返回true，否则返回false（队列Q已存在）// bool QueueEmpty(LinkQueue Q){//     return (Q->front==NULL);// }// //返回队列Q中元素个数，即队列的长度（队列Q已存在）// int QueueLength(LinkQueue Q){//     LinkNode temp = Q->front;//     int i = 0;//     while(temp){//         temp = temp->next;//         i++;//     }//     return i;// }// //用e返回队头元素。（队列Q已存在）// bool GetHead(LinkQueue Q,DataType &e){//     if(!Q->front)return false;//     e = Q->front->data;//     return true;// }// //插入元素e为新的队尾元素（队列Q已存在）// bool EnQueue(LinkQueue &Q,DataType e){//     LinkNode temp = (LinkNode)malloc(sizeof(LNode));//     if(!temp)return false;//     temp->data = e;//     temp->next = NULL;//     if(!Q->front){//         Q->front =temp;//         Q->rear = temp;//     }else{//         Q->rear->next = temp;//         Q->rear = temp; //     }//     return true;// }// //删除Q的队头元素，并用e返回其值。（队列Q已存在）// bool DeQueue(LinkQueue &Q,DataType &e){//     if(!Q->front)return false;//     LinkNode temp = Q->front;//     e = temp->data;//     Q->front = temp->next;//     if(Q->rear == temp){//         Q->rear=Q->front=NULL;//     }//     free(temp);//     return true;// }// //按前后顺序输出队列Q的所有元素值（队列Q已存在）// bool QueueTraverse(LinkQueue Q){//     LinkNode temp = Q->front;//     while(temp){//         cout<<temp->data;//         temp = temp->next;//     }//     cout<<endl;//     return true;// }</code></pre><pre class=" language-flow"><code class="language-flow">st=>start: 开始e=>end: 结束cond0=>condition: 还有未处理的括号？cond1=>condition: a是左括号？cond2=>condition: 栈空？cond3=>condition: b与a匹配？cond4=>condition: 栈空？op1=>operation: 扫描下一个括号aop2=>operation: 匹配成功op3=>operation: a压入栈顶op4=>operation: 弹出栈顶元素bop5=>operation: 匹配失败st->cond0cond0(yes,right)->op1->cond1cond1(yes,right)->op3->cond0cond0(no)->cond4cond4(yes,right)->op2->econd4(no)->op5cond1(no)->cond2cond2(yes,right)->op5->econd2(no)->op4->cond3cond3(yes,right)->cond0cond3(no)->op5</code></pre>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> data_structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stack</title>
      <link href="posts/stack.html"/>
      <url>posts/stack.html</url>
      
        <content type="html"><![CDATA[<h1 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h1><h2 id="顺序栈结点描述"><a href="#顺序栈结点描述" class="headerlink" title="顺序栈结点描述"></a>顺序栈结点描述</h2><pre class=" language-c++"><code class="language-c++">#define DataType int#define maxsize 10typedef struct SequenceStack{    DataType elem[maxsize];    int top;}SequenceStack;</code></pre><h2 id="链栈结点"><a href="#链栈结点" class="headerlink" title="链栈结点"></a>链栈结点</h2><pre class=" language-c++"><code class="language-c++">#define datatype inttypedef struct node{    datatype elem;    struct node *next;}Node,*LinkStack;</code></pre><h2 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h2><pre class=" language-c++"><code class="language-c++">#define Maxsize 10        //定义栈中元素的最大个数typedef struct{    ElemType data[Maxsize]；//静态数组存放栈中元素    int top0；//0号栈顶指针    int top1；//1号栈我顶指针}Shstack；</code></pre><p>栈满条件：top0+1==top1</p><h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><pre class=" language-markdown"><code class="language-markdown">ADT Stack{<span class="token code keyword">    数据对象:    D = {a_i|a_i∈Elemset,i=1,2,...n,n≥0}</span><span class="token code keyword">    数据关系:    R_1 = {&lt;a_{i-1},a_i>|a_{i-1},a_i∈D,i=1,2,...n}</span><span class="token code keyword">    基本操作:</span><span class="token code keyword">        InitStack(&amp;S);        //构造一个空的栈S</span><span class="token code keyword">        DestroyStack(&amp;S);    //销毁栈S（栈S已存在）</span><span class="token code keyword">        ClearStack(&amp;S);        //将S重清为空栈(栈S已存在)</span><span class="token code keyword">        StackEmpty(S);        //若S为空栈，则返回true，否则返回false（栈S已存在）</span><span class="token code keyword">        StackLength(S);        //返回栈S中元素个数，即栈的长度（栈S已存在）</span><span class="token code keyword">        GetTop(S);            //返回栈顶元素。（栈S已存在）</span><span class="token code keyword">        Push(&amp;S,e);//插入元素e为新的栈顶元素（栈S已存在）</span><span class="token code keyword">        Pop(&amp;S,&amp;e);//删除S的栈顶元素，并用e返回其值。（栈S已存在）</span><span class="token code keyword">        PrintStack(S);//按前后顺序输出栈S的所有元素值（栈S已存在）</span>}ADT List</code></pre><h1 id="顺序栈的实现"><a href="#顺序栈的实现" class="headerlink" title="顺序栈的实现"></a>顺序栈的实现</h1><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <cstdlib>#define DataType int#define maxsize 1024//定义栈中元素的最大个数using namespace std;typedef struct SequenceStack{    DataType elem[maxsize]; //静态数组存放栈中元素    int top;                //栈顶指针}SequenceStack;bool InitStack(SequenceStack &S);        //构造一个空的栈Sbool ClearStack(SequenceStack &S);        //将S重清为空栈(栈S已存在)bool StackEmpty(SequenceStack S);        //若S为空栈，则返回true，否则返回falseint StackLength(SequenceStack S);        //返回栈S中元素个数，即栈的长度bool GetTop(SequenceStack S,DataType &e);            //返回栈顶元素。bool Push(SequenceStack &S,DataType e);//插入元素e为新的栈顶元素bool Pop(SequenceStack &S,DataType &e);//删除S的栈顶元素，并用e返回其值。 void PrintStack(SequenceStack S);//按前后顺序输出线性表L的所有元素值 int main(){    SequenceStack S;    int e;    InitStack(S);    cin>>e;    while(e!=-1){        Push(S,e);        cin>>e;    }    PrintStack(S);    Push(S,7);    PrintStack(S);    GetTop(S,e);    cout<<e<<endl;    Pop(S,e);    cout<<e<<endl;    PrintStack(S);    ClearStack(S);    cout<<StackLength(S)<<endl;    cout<<StackEmpty(S)<<endl;}// 栈的初始化 bool InitStack(SequenceStack &S){    S.top = -1;}//将S重清为空栈(栈S已存在)bool ClearStack(SequenceStack &S){    S.top = -1;}    // 检测栈是否为空 bool StackEmpty(SequenceStack S){    if(S.top == -1)return true;    return false;}// 获取栈中元素个数 int StackLength(SequenceStack S){    return S.top+1;}// 获取栈顶元素 bool GetTop(SequenceStack S,DataType &e){    if(StackEmpty(S))return false;    e = S.elem[S.top];    return true;}// 入栈 bool Push(SequenceStack &S,DataType e){    if(S.top == maxsize-1)return false;    S.elem[++S.top] = e;    return true;}// 出栈 bool Pop(SequenceStack &S,DataType &e){    if(StackEmpty(S))return false;    e = S.elem[S.top--];    return true;}//打印栈void PrintStack(SequenceStack S){    int i = S.top;    while(i>-1){        cout<<S.elem[i];        i--;    }    cout<<endl;}</code></pre><h1 id="链栈实现"><a href="#链栈实现" class="headerlink" title="链栈实现"></a>链栈实现</h1><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <cstdlib>#define datatype intusing namespace std;typedef struct node{    datatype elem;    struct node *next;}Node,*LinkStack;bool InitStack(LinkStack &S);        //构造一个空的栈Sbool ClearStack(LinkStack &S);        //将S重清为空栈(栈S已存在)bool StackEmpty(LinkStack S);        //若S为空栈，则返回true，否则返回falseint StackLength(LinkStack S);        //返回栈S中元素个数，即栈的长度bool GetTop(LinkStack S,datatype &e);            //返回栈顶元素。bool Push(LinkStack &S,datatype e);//插入元素e为新的栈顶元素bool Pop(LinkStack &S,datatype &e);//删除S的栈顶元素，并用e返回其值。 void PrintStack(LinkStack S);//按前后顺序输出线性表L的所有元素值 int main(){    LinkStack S;    InitStack(S);    cout<<InitStack(S)<<endl;    cout<<StackEmpty(S)<<endl;    int n;    cin>>n;    while(n != -1){        Push(S,n);        cin>>n;    }    PrintStack(S);    GetTop(S,n);    cout<<n<<endl;    Pop(S,n);    cout<<n<<endl;    cout<<StackLength(S)<<endl;    PrintStack(S);    return 0;}//构造一个空的栈Sbool InitStack(LinkStack &S){    S = (Node *)malloc(sizeof(Node));    if(!S)return false;    S->next = NULL;    return true;}//将S重清为空栈(栈S已存在)bool ClearStack(LinkStack &S){    S->next = NULL;}//若S为空栈，则返回true，否则返回falsebool StackEmpty(LinkStack S){    if(!S->next)return true;    return false;}        //返回栈S中元素个数，即栈的长度int StackLength(LinkStack S){    int length = 0;    LinkStack temp = S->next;    while(temp){        length++;        temp = temp->next;    }    return length;}//返回栈顶元素。bool GetTop(LinkStack S,datatype &e){    if(S->next){        e = S->next->elem;        return true;        }    return false;}//插入元素e为新的栈顶元素bool Push(LinkStack &S,datatype e){    Node * temp = (Node *)malloc(sizeof(Node));    if(!temp)return false;    temp->elem = e;    temp->next=S->next;    S->next = temp;    return true;}//删除S的栈顶元素，并用e返回其值。bool Pop(LinkStack &S,datatype &e){    if(!S->next)return false;    Node * temp = S->next;    e = temp->elem;    S->next = temp->next;    free(temp);    return true;}//按前后顺序输出线性表L的所有元素值 void PrintStack(LinkStack S){    Node * temp = S->next;    while(temp){        cout<<temp->elem;        temp = temp->next;    }    cout<<endl;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> data_structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MoreLinkList</title>
      <link href="posts/morelinklist.html"/>
      <url>posts/morelinklist.html</url>
      
        <content type="html"><![CDATA[<h2 id="单链表结点描述"><a href="#单链表结点描述" class="headerlink" title="单链表结点描述"></a>单链表结点描述</h2><pre class=" language-c++"><code class="language-c++">#define datatype int        //定义默认数据类型 typedef struct node{        //定义单链表结点类型    datatype elem;            //数据域    struct node *next;        //指针域}LNode,*LinkList;</code></pre><h2 id="双链表结点描述"><a href="#双链表结点描述" class="headerlink" title="双链表结点描述"></a>双链表结点描述</h2><pre class=" language-c++"><code class="language-c++">#define datatype int        //定义默认数据类型 typedef struct node{        //定义单链表结点类型    datatype elem;            //数据域    struct node *prior,*next;        //指针域}DLNode,*DLinkList;</code></pre><h2 id="静态链表结点描述"><a href="#静态链表结点描述" class="headerlink" title="静态链表结点描述"></a>静态链表结点描述</h2><pre class=" language-c++"><code class="language-c++">#define datatype int        //定义默认数据类型 #define MaxSize 50            //静态链表最大长度typedef struct{    datatype elem;    int next;                //下一个元素的数组下标}SLinkList[MaxSize];</code></pre><p>双链表基本操作的实现</p><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <cstdlib>#define datatype intusing namespace std;typedef struct node{    datatype elem;    struct node *prior,*next;}DLNode,*DLinkList;bool InitList(DLinkList &L);//初始化链表bool InsertNextNode(DLNode *L,DLNode *S);//在L结点之后插入S结点bool DeleteNextList(DLNode *L);//删除p结点的后继结点void DestoryList(DLinkList &L);//销毁链表bool HeadInsertList(DLinkList &L);//头插法int LoctionElem(DLinkList L,datatype item);//在表L中查找具有给定关键字值的元素,成功返回下标。 DLNode * GetNode(DLinkList L,int i);//在表L中查找第i的元素,并返回该结点。 void PrintList(DLinkList L);//按前后顺序输出线性表L的所有元素值 int main(){    DLinkList head;    InitList(head);    HeadInsertList(head);    PrintList(head);    cout<<LoctionElem(head,3)<<endl;    DeleteNextList(head);    PrintList(head);    cout<<GetNode(head,2)->elem<<endl;}//初始化链表bool InitList(DLinkList &L){    L = (DLNode *)malloc(sizeof(DLNode)); //初始化头结点    if(!L)return false;//    L->next = NULL;    L->prior = NULL;    return true;}//在L结点之后插入S结点bool InsertNextNode(DLNode *L,DLNode *S){    if(!L||!S)return false;     S->next = L->next;     S->prior = L;     L->next = S;     if(S->next)     S->next->prior = S;}//删除p结点的后继结点bool DeleteNextList(DLNode *L){    DLNode *temp;    if(!L||!L->next)return false;    temp = L->next;    L->next = temp->next;    if(temp->next)        temp->next->prior = L;    free(temp);    return true;}//销毁链表void DestoryList(DLinkList &L){    while(L->next){        DeleteNextList(L);    }    free(L);//释放头结点    L=NULL;//头指针指向NULL}//头插法bool HeadInsertList(DLinkList &L){    int x;    cin>>x;    while(x!=-1){        DLNode *temp = (DLNode *)malloc(sizeof(DLNode));        if(!temp) return false;        temp->elem = x;        InsertNextNode(L,temp);        cin>>x;    }    return true;}//在表L中查找具有给定关键字值的元素,成功返回下标。int LoctionElem(DLinkList L,datatype item){    DLinkList temp = L->next;    int i = 0;    while(temp){        i++;        if(temp->elem == item)return i;        temp = temp->next;    }    return -1;}//在表L中查找第i的元素,并返回该结点。DLNode * GetNode(DLinkList L,int i){    DLinkList temp = L;    while(i > 0 && temp){        i--;        temp = temp->next;    }    return temp;}//打印链表void PrintList(DLinkList L){    DLinkList temp = L->next;    while(temp){        cout<<temp->elem;        temp=temp->next;    }    cout<<endl;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> data_structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LinkList</title>
      <link href="posts/linklist.html"/>
      <url>posts/linklist.html</url>
      
        <content type="html"><![CDATA[<h1 id="链表的定义"><a href="#链表的定义" class="headerlink" title="链表的定义"></a>链表的定义</h1><h2 id="单链表结点描述"><a href="#单链表结点描述" class="headerlink" title="单链表结点描述"></a>单链表结点描述</h2><pre class=" language-c++"><code class="language-c++">#define datatype int        //定义默认数据类型 typedef struct node{        //定义单链表结点类型    datatype elem;            //数据域    struct node *next;        //指针域}LNode,*LinkList;</code></pre><p>强调这是一个单链表——使用Linklist，如函数传递参数<br>强调这是一个结点——使用LNode *，如函数返回一个结点</p><p>eg:    LNode * ListFind(LinkList L,datatype i)</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><strong>不带头结点的初始化</strong></p><pre class=" language-c++"><code class="language-c++">//初始化一个空的单链表bool InitList(LinkList &L){    L = NULL；//空表，暂时还没有任何结点    return true;}...LinkList L;        //声明一个指向单链表的指针InitList(L);    //初始化一个空表</code></pre><p>其中<code>bool InitList(LinkList &amp;L)</code>等价于<code>bool InitList(LNode *&amp;L)</code></p><p>理解 <code>&amp;*p</code>等于``*&amp;p`等于 p, 也就是 p 指向的 变量的地址</p><p><strong>带头结点的初始化</strong></p><pre class=" language-c++"><code class="language-c++">//初始化一个空的单链表bool InitList(LinkList &L){    L=(LNode*)malloc(sizeof(LNode));    //分配一个头结点    if(L==NULL)                            //内存不足，分配失败        return false;    L->next=NULL;                        //头结点之后暂时还没有节点    return true;}...LinkList L;        //声明一个指向单链表的指针InitList(L);    //初始化一个空表</code></pre><h1 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h1><pre class=" language-markdown"><code class="language-markdown">ADT List{<span class="token code keyword">    数据对象:    D = {a_i|a_i∈Elemset,i=1,2,...n,n≥0}</span><span class="token code keyword">    数据关系:    R_1 = {&lt;a_{i-1},a_i>|a_{i-1},a_i∈D,i=1,2,...n,n≥0}</span><span class="token code keyword">    基本操作:</span><span class="token code keyword">        InitList(&amp;L);        //构造一个空的线性表L</span><span class="token code keyword">        DestroyList(&amp;L);    //销毁线性表L（线性表L已存在）</span><span class="token code keyword">        ClearList(&amp;L);        //将L重置为空表(线性表L已存在)</span><span class="token code keyword">        ListEmpty(L);        //若L为空表，则返回true，否则返回false</span><span class="token code keyword">        ListLength(L);        //返回L中数据元素个数</span><span class="token code keyword">        GetElem(L,i,&amp;e)        //用e返回L中第i个数据元素的值。</span><span class="token code keyword">        Listlnsert(&amp;L,i,Item);//在表L中的第i个位置后插入指定元素e</span><span class="token code keyword">        ListDelete(&amp;L,i);//删除表L中第i个位置后的元素 </span><span class="token code keyword">        GetNext(L,Item,&amp;p);    //在表L中查找具有给定关键字值的元素的下一位,并赋值给形参。</span><span class="token code keyword">        LocateElem(L,Item);    //在表L中查找具有给定关键字值的元素,成功返回下标。 </span><span class="token code keyword">        GetPrior(L,Item,&amp;p);//在表L中查找具有给定关键字值的元素的前一位,并赋值给形参。</span><span class="token code keyword">        PrintList(L);//按前后顺序输出线性表L的所有元素值 </span>}ADT List</code></pre><h1 id="带头结点单链表的实现"><a href="#带头结点单链表的实现" class="headerlink" title="带头结点单链表的实现"></a>带头结点单链表的实现</h1><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <cstdlib>#define datatype intusing namespace std;typedef struct node{    datatype elem;    struct node *next;}LNode,*LinkList;bool InitList(LinkList &L);                 //初始化一个空的单链表bool ListInsert(LinkList &L,int i,datatype e);//插入操作。在表L中的第i个位置上插入指定元素e。bool ListDelete(LinkList &L,int i,datatype &e);//删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值。LNode * GetNode(LinkList L,int i);          //查找第i个结点datatype GetElem(LinkList L,int i);             //按位查找操作。获取表L中第个位置的元素的值。LNode * LocateElem(LinkList L,datatype e);     //按值查找操作。在表L中查找具有给定关键字值的元素。int ListLength(LinkList L);                    //查询单链表表长，返回表长void print(LinkList L);                        //打印单链表void ListTailInsert(LinkList &L);            //尾插法，顺序。void ListHeadInsert(LinkList &L);            //头插法，倒序。int main(){    LinkList head;    int e;    InitList(head);    ListHeadInsert(head);        //ListTailInsert(head);    print(head);    ListInsert(head,2,3);    print(head);    ListDelete(head,3,e);    print(head);    cout<<GetElem(head,2)<<endl;    cout<<LocateElem(head,5)->elem<<endl;} //初始化一个空的单链表bool InitList(LinkList &L){    L=(LNode*)malloc(sizeof(LNode));    //分配一个头结点    if(L==NULL)                            //内存不足，分配失败        return false;    L->next=NULL;                        //头结点之后暂时还没有节点    return true;}//插入操作。在表L中的第i个位置上插入指定元素e。bool ListInsert(LinkList &L,int i,datatype e){    LinkList temp = GetNode(L,i-1);    LNode * s = (LinkList)malloc(sizeof(LNode));    s->elem = e;    s->next = temp->next;    temp->next = s;    return true;}//删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值。bool ListDelete(LinkList &L,int i,datatype &e){    LinkList temp = GetNode(L,i-1);    LNode *p = temp->next;    temp->next = p->next;    e = p->elem;    free(p);    return true;}//查找第i个结点LNode * GetNode(LinkList L,int i){    if(i<0||i>ListLength(L)){        return NULL;    }    LinkList temp = L;    int j = 0;    while(temp && j != i){        temp = temp->next;        j++;    }    return temp;}//按位查找操作。获取表L中第i个位置的元素的值。datatype GetElem(LinkList L,int i){    LinkList temp = GetNode(L,i);    return temp->elem;}//按值查找操作。在表L中查找具有给定关键字值的元素。LNode * LocateElem(LinkList L,datatype e){    LNode * temp = L;    while(temp&&temp->elem!=e)        temp = temp->next;    return temp;}//查询单链表表长，返回表长int ListLength(LinkList L){    LinkList temp = L->next;    int i = 0;    while(temp){        temp = temp->next;        i++;    }    return i;}//打印单链表void print(LinkList L){    LNode * temp = L->next;    while(temp){        cout<<temp->elem;        temp = temp->next;    }    cout<<endl;}//尾插法，顺序。void ListTailInsert(LinkList &L){    int elem;    cin>>elem;    LNode * r = L;        //设置一个尾指针，每次在尾指针后面插入    while(elem != -1){        LNode * temp = (LNode *)malloc(sizeof(LNode));        temp->elem = elem;        r->next = temp;        r = r->next;        cin>>elem;    }    r->next = NULL;}//头插法，倒序。void ListHeadInsert(LinkList &L){    int elem;    cin>>elem;    while(elem != -1){        LNode * temp = (LNode *)malloc(sizeof(LNode));        temp->elem = elem;        temp->next = L->next;        L->next = temp;        cin>>elem;    }}</code></pre><h1 id="不带头结点单链表的实现"><a href="#不带头结点单链表的实现" class="headerlink" title="不带头结点单链表的实现"></a>不带头结点单链表的实现</h1><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <cstdlib>#define datatype intusing namespace std;typedef struct node{    datatype elem;    struct node *next;}LNode,*LinkList;bool InitList(LinkList &L);                 //初始化一个空的单链表bool ListInsert(LinkList &L,int i,datatype e);//插入操作。在表L中的第i个位置上插入指定元素e。bool ListDelete(LinkList &L,int i,datatype &e);//删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值。LNode * GetNode(LinkList L,int i);          //查找第i个结点datatype GetElem(LinkList L,int i);             //按位查找操作。获取表L中第个位置的元素的值。LNode * LocateElem(LinkList L,datatype e);     //按值查找操作。在表L中查找具有给定关键字值的元素。int ListLength(LinkList L);                    //查询单链表表长，返回表长void print(LinkList L);                        //打印单链表void ListTailInsert(LinkList &L);            //尾插法，顺序。void ListHeadInsert(LinkList &L);            //头插法，倒序。int main(){    LinkList L;    int e;    InitList(L);    ListTailInsert(L);        //ListTailInsert(L);    print(L);    ListInsert(L,2,3);    print(L);    ListDelete(L,3,e);    print(L);    cout<<GetElem(L,2)<<endl;    cout<<LocateElem(L,5)->elem<<endl;} //初始化一个空的单链表bool InitList(LinkList &L){    L = NULL;                        return true;}//插入操作。在表L中的第i个位置上插入指定元素e。bool ListInsert(LinkList &L,int i,datatype e){    LinkList temp = GetNode(L,i-1);    if(!temp){        if(i == 1){            LNode * s = (LinkList)malloc(sizeof(LNode));            s->elem = e;            s->next = L;            L = s;            return true;        }        else            return false;    }    LNode * s = (LinkList)malloc(sizeof(LNode));    s->elem = e;    s->next = temp->next;    temp->next = s;    return true;}//删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值。bool ListDelete(LinkList &L,int i,datatype &e){    LinkList temp = GetNode(L,i-1);    if(!temp){        L=NULL;        return true;    }    LNode *p = temp->next;    temp->next = p->next;    e = p->elem;    free(p);    return true;}//查找第i个结点LNode * GetNode(LinkList L,int i){    if(i<1||i>ListLength(L)){        return NULL;    }    LinkList temp = L;    int j = 1;    while(temp && j != i){        temp = temp->next;        j++;    }    return temp;}//按位查找操作。获取表L中第i个位置的元素的值。datatype GetElem(LinkList L,int i){    LinkList temp = GetNode(L,i);    if(temp)    return temp->elem;}//按值查找操作。在表L中查找具有给定关键字值的元素。LNode * LocateElem(LinkList L,datatype e){    LNode * temp = L;    while(temp&&temp->elem!=e)        temp = temp->next;    return temp;}//查询单链表表长，返回表长int ListLength(LinkList L){    LinkList temp = L;    int i = 0;    while(temp){        temp = temp->next;        i++;    }    return i;}//打印单链表void print(LinkList L){    LNode * temp = L;    while(temp){        cout<<temp->elem;        temp = temp->next;    }    cout<<endl;}//尾插法，顺序。void ListTailInsert(LinkList &L){    int elem;    cin>>elem;    LNode * r = L;        //设置一个尾指针，每次在尾指针后面插入    if(elem!=-1){        LNode * temp = (LNode *)malloc(sizeof(LNode));        temp->elem = elem;        L=temp;         r=temp;        cin>>elem;        while(elem != -1){            LNode * temp = (LNode *)malloc(sizeof(LNode));            temp->elem = elem;            r->next = temp;            r = r->next;            cin>>elem;        }        r->next = NULL;    }}//头插法，倒序。void ListHeadInsert(LinkList &L){    int elem;    cin>>elem;    while(elem != -1){        LNode * temp = (LNode *)malloc(sizeof(LNode));        temp->elem = elem;        temp->next = L;        L = temp;        cin>>elem;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> data_structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++ 传递指针给函数</title>
      <link href="posts/cpp-passing-pointers-to-functions.html"/>
      <url>posts/cpp-passing-pointers-to-functions.html</url>
      
        <content type="html"><![CDATA[<h1 id="C-传递指针给函数"><a href="#C-传递指针给函数" class="headerlink" title="C++ 传递指针给函数"></a>C++ 传递指针给函数</h1><p>C++ 允许您传递指针给函数，只需要简单地声明函数参数(形参)为指针类型即可。</p><h2 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h2><p>typedef：给变量取一个易记且意义明确的新名字；简化一些比较复杂的类型声明。</p><p>typedef <u>①</u> <u>②</u>:给①起个叫②的别名；</p><pre class=" language-c++"><code class="language-c++">struct [结构体名(临时名字,可省略)]{    类型标识符    成员名；     ...     ...     ...}变量名/序列(新名字);</code></pre><pre class=" language-c++"><code class="language-c++">typedef struct node{    int data;    struct node *lchild;    struct node *rchild;}BTNode,* btnode;BTNode BT;    //①,BT是某个节点的名字BTNode *BT;    //②,BT是指针型变量btnode BT;    //③,BT是指针型变量BT = (BTNode *)malloc(sizeof(BTNode));    //分配空间</code></pre><p>其中②③等价；即(*BT)-&gt;data↔ BT-&gt;data ;</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><pre class=" language-c++"><code class="language-c++">#include<iostream>#include<cstdlib>#define maxsize 1024        //定义最大长度#define datatype int        //定义默认数据类型 using namespace std;typedef struct SquenList{        datatype elem[maxsize];    //用静态的"数组"存放数据元素        int length;                //顺序表的当前长度}SquenList, * sequenlist;    //顺序表的类型定义bool ChangeElem(sequenlist L,int i,datatype Item);    //L是SquenList类型的指针int main(){    datatype temp;    sequenlist s = (SquenList *)malloc(sizeof(SquenList));//声明一个指向顺序表的指针，并为顺序表分配空间        s->length = 6;    for(int i = 0;i<s->length;i++){            s->elem[i] = i;    //{[0],[1],[2],[3],[4],[5]}    }    ChangeElem(s,4,1);    //{[0],[1],[2],[3],[1],[5]};指针传递给函数时，形参传入的是地址;s表示指向顺序表的地址}bool ChangeElem(sequenlist L,int i,datatype Item){    if(i<0||i>L->length-1){        cout<<"err"<<endl;        return false;    }else {        L->elem[i] = Item;       return true;     }}</code></pre><p>形参定义为指针类型时，实参传递一定是地址。</p><pre class=" language-c++"><code class="language-c++">void func1(int *a);int main (){   int b;   func1( &b );   return 0;}</code></pre><pre class=" language-c++"><code class="language-c++">void func1(int *a);int main (){   int b[5]={1,2,3,4,5};   func1(b);   return 0;}</code></pre><p>数组变量名为首地址。</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 中指针和引用的区别</title>
      <link href="posts/cpp-difference-between-pointers-and-references.html"/>
      <url>posts/cpp-difference-between-pointers-and-references.html</url>
      
        <content type="html"><![CDATA[<h2 id="C-引用与指针的比较"><a href="#C-引用与指针的比较" class="headerlink" title="C++ 引用与指针的比较"></a>C++ 引用与指针的比较</h2><p>引用是 C++ 中的概念，初学者容易把引用和指针混淆一起。</p><p>引用是变量的别名，不会产生副本，和原变量是同一个东西，因此对引用变量的操作就是对原变量的操作。在底层，<strong>引用变量</strong>由<u>指针按照指针常量的方式实现</u>!</p><p>一下程序中，n 是m的一个引用（reference），m 是被引用物（referent）。</p><pre class=" language-c++"><code class="language-c++">int m; int &n = m; </code></pre><p>n 相当于 m 的别名（绰号），对 n 的任何操作就是对m的操作。</p><p>所以 n 既不是m的拷贝，也不是指向 m 的指针，其实n就是 m 它自己。</p><p>引用的规则：</p><ul><li>（1）引用被创建的同时必须被初始化（指针则可以在任何时候被初始化）。</li><li>（2）不能有 NULL 引用，引用必须与合法的存储单元关联（指针则可以是 NULL）。</li><li>（3）一旦引用被初始化，就不能改变引用的关系（指针则可以随时改变所指的对象）。</li></ul><p>以下示例程序中，k 被初始化为i的引用。</p><p>语句 k = j 并不能将 k 修改成为j的引用，只是把k的值改变成为 6。</p><p>由于 k 是 i 的引用，所以i的值也变成了 6。</p><pre class=" language-c++"><code class="language-c++">int i = 5; int j = 6; int &k = i; k = j; // k 和 i 的值都变成了 6;</code></pre><p>引用的主要功能是传递函数的参数和返回值。</p><p>C++ 语言中，函数的参数和返回值的传递方式有三种：值传递、指针传递和引用传递。</p><h2 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h2><p>由于 Func1 函数体内的 x 是外部变量 n 的一份拷贝,函数体内的 x有新的存储空间,改变 x 的值不会影响 n,函数执行完毕后x会被销毁， 所以 n 的值仍然是 0。</p><pre class=" language-c++"><code class="language-c++">void Func1(int x) {     x = x + 10; } ... int n = 0; Func1(n); cout << "n = " << n << endl; // n = 0 </code></pre><h2 id="指针传递"><a href="#指针传递" class="headerlink" title="指针传递"></a>指针传递</h2><p>将指针作为函数参数，可以看作是将指针所指变量的<strong>地址</strong>传入函数，形参指针指向该地址，<strong>即两个指针指向同一地址</strong>；如果在函数中对这个地址中的元素进行改变，传入指针所指变量的数据就会确实的发生改变。</p><p>由于 Func2 函数体内的 x 是指向外部变量 n 的指针，* x表示取x中存储的地址的里面的值，即指针所指变量的值；改变该指针的内容将导致 n 的值改变，所以 n 的值成为 10。</p><pre class=" language-c++"><code class="language-c++">void Func2(int *x) {     (* x) = (* x) + 10; } ...int n = 0; Func2(&n); cout << "n = " << n << endl; // n = 10 </code></pre><p>但是如果在函数中改变的是指针指向的地址，则对传入的指针变量不会产生影响。</p><pre class=" language-c++"><code class="language-c++">int a = 10;        //全局变量void Func3(int *x) {     x = &a; } ...int n = 0;int *m = &nFunc3(m); cout << "n = " << *m << endl; // n = 0 </code></pre><p>改变指针变量指向的地址，相当于使指针x从指向实参n变成指向全局变量a，而形参值的改变不会影响实参的值，所以传入指针所指地址不会发生改变。</p><p>如果想要改变指针指向的地址，就需要在函数中传递指针的指针。</p><pre class=" language-c++"><code class="language-c++">int a = 10;        //全局变量void Func3(int **x) {     *x = &a; } ...int n = 0;int *m = &nFunc3(&m); cout << "n = " << *m << endl; // n = 10 </code></pre><h2 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h2><p>由于 Func3 函数体内的 x 是外部变量 n 的引用，x 和 n 是同一个东西，<strong>即一个地址两个名字</strong>；改变 x 等于改变 n，所以 n 的值成为 10。</p><pre class=" language-c++"><code class="language-c++">void Func3(int &x) {     x = x + 10; } ... int n = 0; Func3(n); cout << "n = " << n << endl; // n = 10</code></pre><p>有了引用之后，改变指针指向的地址就可以通过指针的引用来实现。</p><pre class=" language-c++"><code class="language-c++">int a = 10;        //全局变量void Func3(int *&x) {     *x = &a; } ...int n = 0;int *m = &nFunc3(m); cout << "n = " << *m << endl; // n = 10 </code></pre><p>对比上述三个示例程序，会发现”引用传递”的性质像”指针传递”，而书写方式像”值传递”。</p><p>实际上”引用”可以做的任何事情”指针”也都能够做，为什么还要”引用”这东西？</p><p>答案是”用适当的工具做恰如其分的工作”。</p><p>指针能够毫无约束地操作内存中的任何东西，尽管指针功能强大，但是非常危险。</p><p>如果的确只需要借用一下某个对象的”别名”，那么就用”引用”，而不要用”指针”，以免发生意外。</p><p><u>当用指针或者引用做形参来改变主函数中变量的值得时候，指针是值传递，传递的是指针变量的值；而引用是址传递，传递的是变量的地址。另外还有一点要知道，指针做形参，传递指针的时候，会产生一个临时的<strong>指针变量</strong>，需要分配额外的内存空间；但是传引用的话则不会，<strong>引用变量</strong>的地址由编译器掌握，程序员无法直接对它进行存取，对引用取地址&amp;，相当于取原变量的地址</u></p><h1 id="amp-p和-amp-p的理解"><a href="#amp-p和-amp-p的理解" class="headerlink" title="*&amp;p和&amp;*p的理解"></a>*&amp;p和&amp;*p的理解</h1><p>指针和地址其实是一个概念，但又有所区别。</p><p>*&amp;p=*q表示:指针变量p是q的引用</p><p>在存储中，每个存储单元就是一个格子。地址就是格子的编号，数据就是格子里面存放的内容。</p><p><strong>&amp;是取地址运算符</strong>，如有 int a; 即分配一个格子起名叫a，&amp;a就是取a的地址，即该盒子的编号。</p><p>*<strong>是取值运算符</strong>，<code>*(&amp;a) </code>就是打开a对应的格子，取出里面的数据，即<code>*(&amp;a)</code>和a等价。</p><p><code>int *p=&amp;a；</code>相当于<code>int *p; p=&amp;a;</code></p><p>p存放的是a的地址，*p也等价于 a。指针变量p既然是变量，也同变量a一样对应一个格子，也有一个地址编号，&amp;p就是取指针p的地址。这样就好理解二级指针了。</p><p><strong>*p和**p的区别</strong></p><p>int *p ：一级指针，表示p所指向的地址里面存放的是一个int类型的值</p><p>int **p ：二级指针，表示p所指向的地址里面存放的是一个指向int类型的指针（即p指向的地址里面存放的是一个指向int的一级指针）</p><p>例：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//定义整形变量</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//定义一个指针指向这个变量</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>p1<span class="token operator">=</span><span class="token operator">&amp;</span>p<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//定义一个二级指针指向p指针</span><span class="token comment" spellcheck="true">/*   那么取出5的方式都有哪些呢？ */</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a=%d"</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a=%d"</span><span class="token punctuation">,</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a=%d"</span><span class="token punctuation">,</span><span class="token operator">*</span><span class="token operator">*</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>以上3行输出的值都是5 。</p><h3 id="amp-p和-amp-p"><a href="#amp-p和-amp-p" class="headerlink" title="*&amp;p和&amp;*p"></a>*&amp;p和&amp;*p</h3><p>根据运算优先级，*&amp;p 等价于*(&amp;p)。&amp;*p 等价于&amp;(*p)。</p><p>如果p是int *指针变量，那么*&amp;p = p，&amp;*p = p，都是p.</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//定义整形变量</span><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//定义一个指针指向这个变量，即p=&amp;a</span><span class="token comment" spellcheck="true">//*&amp;p-->一个int指针的引用</span><span class="token comment" spellcheck="true">//&amp;*p-->*P等同于变量a;  所以&amp;(*p)就是&amp;a;</span></code></pre><p><strong>参考</strong></p><p>- <a href="https://www.runoob.com/w3cnote/cpp-difference-between-pointers-and-references.html">菜鸟教程</a></p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SequenceList</title>
      <link href="posts/sequencelist.html"/>
      <url>posts/sequencelist.html</url>
      
        <content type="html"><![CDATA[<h1 id="顺序表的定义"><a href="#顺序表的定义" class="headerlink" title="顺序表的定义"></a>顺序表的定义</h1><h2 id="静态分配存储"><a href="#静态分配存储" class="headerlink" title="静态分配存储"></a>静态分配存储</h2><pre class=" language-c++"><code class="language-c++">#define maxsize 1024        //定义最大长度#define datatype int        //定义默认数据类型 typedef struct SquenList{    datatype elem[maxsize];    //用静态的"数组"存放数据元素        int length;                //顺序表的当前长度}SquenList, * sequenlist;    //顺序表的类型定义SquenList S;                //声明一个顺序表S.length = 0;                //初始化</code></pre><h2 id="动态分配存储"><a href="#动态分配存储" class="headerlink" title="动态分配存储"></a>动态分配存储</h2><pre class=" language-c++"><code class="language-c++">#define InitSize 100        //顺序表的初始长度typedef struct SquenList{        datatype *elem;            //用静态的"数组"存放数据元素        int length,MaxSize;        //顺序表的当前长度和最大容量}SquenList, * sequenlist;    //顺序表的类型定义sequenlist S;                //声明一个顺序表S->data = (SquenList *)malloc(sizeof(SquenList)*InitSize);    //初始化S->length = 0;S->MaxSize = InitSize;</code></pre><p>malloc函数返回一个指针，需要强制转型为你定义的数据元素类型指针;</p><p>malloc函数的参数，指明要分配多大的连续内存空间;</p><p>指针同一维数组理解；</p><pre class=" language-c++"><code class="language-c++">int A[MaxSize];int n;</code></pre><p>答卷时，简洁定义。</p><h1 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h1><pre class=" language-markdown"><code class="language-markdown">ADT List{<span class="token code keyword">    数据对象:    D = {a_i|a_i∈Elemset,i=1,2,...n,n≥0}</span><span class="token code keyword">    数据关系:    R_1 = {&lt;a_{i-1},a_i>|a_{i-1},a_i∈D,i=1,2,...n,n≥0}</span><span class="token code keyword">    基本操作:</span><span class="token code keyword">        InitList(&amp;L);        //构造一个空的线性表L</span><span class="token code keyword">        DestroyList(&amp;L);    //销毁线性表L（线性表L已存在）</span><span class="token code keyword">        ClearList(&amp;L);        //将L重置为空表(线性表L已存在)</span><span class="token code keyword">        ListEmpty(L);        //若L为空表，则返回true，否则返回false</span><span class="token code keyword">        ListLength(L);        //返回L中数据元素个数</span><span class="token code keyword">        GetElem(L,i,&amp;e)        //用e返回L中第i个数据元素的值。</span><span class="token code keyword">        Listlnsert(&amp;L,i,Item);//在表L中的第i个位置后插入指定元素e</span><span class="token code keyword">        ListDelete(&amp;L,i);//删除表L中第i个位置后的元素 </span><span class="token code keyword">        GetNext(L,Item,&amp;p);    //在表L中查找具有给定关键字值的元素的下一位,并赋值给形参。</span><span class="token code keyword">        LocateElem(L,Item);    //在表L中查找具有给定关键字值的元素,成功返回下标。 </span><span class="token code keyword">        GetPrior(L,Item,&amp;p);//在表L中查找具有给定关键字值的元素的前一位,并赋值给形参。</span><span class="token code keyword">        PrintList(L);//按前后顺序输出线性表L的所有元素值 </span>}ADT List</code></pre><h1 id="顺序表的实现"><a href="#顺序表的实现" class="headerlink" title="顺序表的实现"></a>顺序表的实现</h1><pre class=" language-c++"><code class="language-c++">#include<iostream>#include<cstdlib>#define maxsize 1024        //定义最大长度#define datatype int        //定义默认数据类型 using namespace std;typedef struct SquenList{        datatype elem[maxsize];    //用静态的"数组"存放数据元素        int length;                //顺序表的当前长度}SquenList, * sequenlist;    //顺序表的类型定义void InitList(sequenlist L);                            //初始化表void DestroyList(sequenlist L);                            //销毁int ListLength(sequenlist L);                            //求表长void Listlnsert(sequenlist L,int i,datatype Item);        //在表L中的第i个位置后插入指定元素ebool ListDelete(sequenlist L,int i);                    //删除表L中第i个位置后的元素 bool GetNext(sequenlist L,datatype Item,datatype &p);    //在表L中查找具有给定关键字值的元素的下一位,并赋值给形参。datatype GetNode(sequenlist L,int i);                    //在表L中查找下标为i的元素,并返回元素的值。 int LocateElem(sequenlist L,datatype Item);                //在表L中查找具有给定关键字值的元素,成功返回下标。 bool GetPrior(sequenlist L,datatype Item,datatype &p);    //在表L中查找具有给定关键字值的元素的前一位,并赋值给形参。void PrintList(sequenlist L);                            //按前后顺序输出线性表L的所有元素值 void Empty(sequenlist L);                                //若L为空表，则返回true，否则返回falseint main(){    datatype temp;    sequenlist s = (SquenList *)malloc(sizeof(SquenList));//声明一个指向顺序表的指针，并为顺序表分配空间        InitList(s);    cin>>s->length;    for(int i = 0;i<s->length;i++){            cin>>s->elem[i];    }    Listlnsert(s,2,0);    PrintList(s);    cout<<"ListLength(s):"<<ListLength(s)<<endl;    cout<<"GetNode(s,2):"<<GetNode(s,2)<<endl;    cout<<"GetNext(s,2,&temp):"<<GetNext(s,2,temp)<<endl;    cout<<"temp:"<<temp<<endl;    cout<<"LocateElem(s,2):"<<LocateElem(s,2)<<endl;    cout<<"GetPrior(s,2,&temp):"<<GetPrior(s,2,temp)<<endl;    cout<<"temp:"<<temp<<endl;    cout<<"ListDelete(s,2):"<<ListDelete(s,2)<<endl;    PrintList(s);        cout<<"ListLength(s):"<<ListLength(s)<<endl;}void InitList(sequenlist L){        L->length = 0;}void DestroyList(sequenlist L){    L->length = 0;}int ListLength(sequenlist L){    return L->length;}void Listlnsert(sequenlist L,int i,datatype Item){    if(i<0||i>L->length||L->length==maxsize)        cout<<"err"<<endl;    else{        L->length++;        for(int j = L->length-1;j > i;j--){            L->elem[j] = L->elem[j-1];        }        L->elem[i] = Item;    }}bool ListDelete(sequenlist L,int i){    if(i<0||i>L->length-1||L->length==0)        return false;    else{        for(;i<L->length-1;i++)            L->elem[i] = L->elem[i+1];            L->length --;            return true;    }}bool GetNext(sequenlist L,datatype Item,datatype &p){    for(int i = 0 ; i < L->length-1; i++){        if(L->elem[i] == Item&&i+1<L->length){            p = L->elem[i+1];            cout<<p<<endl;            return true;        }    }    return false;}datatype GetNode(sequenlist L,int i){    if(i<0||i>L->length-1){        cout<<"err"<<endl;        return false;    }else return L->elem[i];}int LocateElem(sequenlist L,datatype Item){    for(int i = 0 ; i < L->length-1; i++){            if(L->elem[i] == Item){        return i;        }    else return 0;    }}bool GetPrior(sequenlist L,datatype Item,datatype &p){    for(int i = 0 ; i < L->length-1; i++){        if(L->elem[i] == Item&&i-1>=0){            p = L->elem[i-1];            cout<<p<<endl;            return true;        }    }    return false;}void PrintList(sequenlist L){    for(int i = 0;i<L->length;i++){        cout<<L->elem[i]<<" ";    }    cout<<endl;}</code></pre><p>由于形参指针没有赋予新值，可以理解为实参的引用！</p><h1 id="顺序表的特点"><a href="#顺序表的特点" class="headerlink" title="顺序表的特点"></a>顺序表的特点</h1><p>①随机访问，即可以在O(1)时间内找到第i个元素。<br>②存储密度高，每个节意只存储数据元素<br>③拓展容量不方便（即便采用动态分配的方式实现，拓展长度的时间复杂度也比较高）<br>④插入、删除操作不方便，需要移动大量元素</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> data_structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Target</title>
      <link href="posts/52273.html"/>
      <url>posts/52273.html</url>
      
        <content type="html"><![CDATA[<h1 id="考研的你必须知道的时间点"><a href="#考研的你必须知道的时间点" class="headerlink" title="考研的你必须知道的时间点"></a><strong>考研的你必须知道的时间点</strong></h1><h2 id="3-4月：协调时间、确定专业、基础复习"><a href="#3-4月：协调时间、确定专业、基础复习" class="headerlink" title="3-4月：协调时间、确定专业、基础复习"></a><strong>3-4月：协调时间、确定专业、基础复习</strong></h2><p>★对准备考研的同学来说，如果是在校大学生，就要<strong>处理好日常上课和研考复习的关系</strong>；如果是在职考生，则要<strong>处理好工作和复习备考的关系</strong>。</p><p>正就读大三的你们面临的压力并不小，因为既要完成学业，也要抽时间系统备考。这个时候_<strong>要全面了解院校和专业信息，初步确定研考目标</strong>_，院校、专业选择是考研的关键一步。提早确定专业方向和院校，会使专业课复习更有针对性。<u>可结合自身实际情况，综合考虑拟报考学校所在城市、专业发展、师资情况、就业前景等因素</u>。</p><p>★_<strong>3-4月务必开始第一轮基础复习</strong>_。在这个阶段需要打牢专业课和英语基础，求全面求细致。在这个期间过一遍专业课书籍、一遍英语单词，应该是没问题的。</p><h2 id="5-6月：一轮复习、夯实基础"><a href="#5-6月：一轮复习、夯实基础" class="headerlink" title="5-6月：一轮复习、夯实基础"></a><strong>5-6月：一轮复习、夯实基础</strong></h2><p>★_<strong>5月，同学们要全面开始第一轮研考复习</strong>_。<strong>要夯实基础，扎扎实实看一遍书，不要急于做模拟题</strong>。对政治、英语、数学三个公共课科目要细致备考。</p><p>对英语，要注重积累英语词汇，提升英语综合能力。对政治不能放松备考，要不断温故知新，也要及时补充和更新知识。对数学，要多练多算，总结答题规律。</p><p>对专业课的复习，要紧跟目标院校的专业课方向，有针对性地收集复习资料，包括往年专业课试题和老师的讲义、论文、专著等。部分学校还会发布当年的考试备考大纲，大家也可及时关注，也可登录相关院校网站查找上年度备考书目，或向在读研究生借阅备考资料。要在前期占有资料的基础上总结形成自己的笔记，构建专业课复习的知识框架。</p><p>★_<strong>6月，同学们要兼顾期末考试和研考复习的时间安排</strong>_。跨专业考研的同学不要因为研考复习而忽略本科专业期末考试的准备。还可以在6月初步制订一份暑假备考计划，考虑是自主复习还是报辅导班，是在校复习还是回家备考，复习时间如何安排等。</p><h2 id="7-8月：强化阶段，关键时期！"><a href="#7-8月：强化阶段，关键时期！" class="headerlink" title="7-8月：强化阶段，关键时期！"></a><strong>7-8月：强化阶段，关键时期！</strong></h2><p><strong>暑假是大家的强化复习阶段，这段时间也是提高专业课成绩的好时机！大家要根据自身情况制订复习计划并严格执行，通过专项突破弥补弱项。</strong></p><p>这个时候注意_<strong>制订复习计划要尽量细致</strong><em>，但也不能难以完成，要让自己每天都有成就感。可以尝试将复习内容分为多个阶段性小目标并限时完成，让复习更有计划性，且容易落实。</em><strong>暑期是提升薄弱科目的好时机，要多安排时间复习薄弱科目，尤其要进行专项突破</strong>_。</p><p>★这段时间，<strong>英语单词绝对不能落下</strong>，要坚持每天回顾，<strong>同时也要开始英语阅读的训练</strong>，每天不用多，精读2-3篇，但是要做到每一篇认真阅读，做完之后认真总结。</p><p>★<strong>数学要真正开始进行强化学习基础阶段，</strong>学过的所有知识，尽管可能刚开始的时候有困难，学起来很吃力，但是熬过这个阶段，就会豁然开朗。</p><p>★<strong>政治复习暑期最晚也要开启了</strong>，每天听几节课，<strong>假期结束最好听完强化班，搞定政治的基础内容</strong>。</p><p>★<strong>专业课可以针对资料的基础、大纲部分进行相关学习了</strong>，最低标准是到假期结束，你专业课能达到期末考试的水平。</p><h2 id="9-11月：了解政策并报名，第三轮复习"><a href="#9-11月：了解政策并报名，第三轮复习" class="headerlink" title="9-11月：了解政策并报名，第三轮复习"></a><strong>9-11月：了解政策并报名，第三轮复习</strong></h2><p>★9月，<strong>考研**</strong>政治、英语、数学大纲会相继发布。各学校的招生简章、专业目录和招生计划等也会陆续出台**。</p><p>在这个阶段，大家不仅要继续完成复习任务，还要注意最新研招政策、公共课大纲，也要留意院校网站公布的研招信息。还要注意<strong>预报名</strong>时间，按时登录中国研究生招生信息网进行预报名。</p><p>★10月，报名搞定后，这段时间的<strong>重点就是第三轮的复习</strong>，对知识点查缺补漏，并估算答题时间，争取在正式考试时能更合理地分配时间。</p><p>★11月，需要进入<strong>冲刺阶段</strong>，对真题开始进行全方位吃透，近十年的真题一定要认真完成，<strong>专业课和政治的学习占比要不断扩大</strong>。</p><p>距离考试越来越近，这个时候一定要注意调整心态，坚定复习信心。</p><h2 id="12月：最后冲刺"><a href="#12月：最后冲刺" class="headerlink" title="12月：最后冲刺"></a><strong>12月：最后冲刺</strong></h2><p>到了十二月，最后的<strong>冲刺阶段</strong>。这一阶段需要做到以下几点：</p><p>★<strong>认真梳理、有效整合各门课的知识</strong>，在头脑中形成对整个章节的知识框架图，做到基础知识烂熟于心；</p><p>★开始<strong>进行考场模拟训练</strong>，在考研的考试时间内，上午做政治或数学，下午做英语，把思维的活跃度训练在各科的考试时间；</p><p>★<strong>对重点和高频考点的知识进行每天的强化背诵</strong>，避免考试紧张大脑瞬间空白；</p><p>★政治一定要<strong>开始最后的押题背诵</strong>，每天保持一定量的记忆，进行知识积累，<strong>这个放心，到时候我会全程和你们在一起。</strong></p><p>★12月中旬，大家就可以凭着网报用户名和密码登录研招网<strong>下载打印准考证</strong>啦！大家这个时候要调整心态，不要因焦虑、恐慌等情绪而轻言放弃考试；也不要熬夜，可按照考试时间提前调整好作息和饮食！</p><h2 id="1-4月：准备复试、调剂"><a href="#1-4月：准备复试、调剂" class="headerlink" title="1-4月：准备复试、调剂"></a><strong>1-4月：准备复试、调剂</strong></h2><p>考研初试并非整个考研流程的结束，不要以为考试正式结束啦！</p><p><strong>初试结束以后，要根据答题情况立刻着手复试和调剂准备，搜集信息并进行有针对性的专业课复习，以便顺利通过复试</strong>。</p><p>另外，大家还要提前详细了解往年调剂流程、注意事项等，及时获取各个研招单位的调剂信息，积极主动联系需要调剂的研招单位，争取最有利的调剂结果！</p><p>22考研的同学们现在就可以有意识地学习学长学姐们的操作啦！到时候不至于过于慌乱不是？</p><p><strong>参考</strong></p><ul><li><a href="https://mp.weixin.qq.com/s/i0OADdO4hMFlZcEdEmE5Tw">考研政治徐涛</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Schedule </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown基本要素</title>
      <link href="posts/3.html"/>
      <url>posts/3.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-Markdown"><a href="#什么是-Markdown" class="headerlink" title="什么是 Markdown?"></a>什么是 Markdown?</h2><p><code>Markdown</code> 是一种文本格式。你可以用它来控制文档的显示。使用 markdown，你可以创建粗体的文字，斜体的文字，添加图片，并且创建列表 等等。基本上来讲，Markdown 就是普通的文字加上 <code>#</code> 或者 <code>*</code> 等符号。</p><h2 id="语法说明"><a href="#语法说明" class="headerlink" title="语法说明"></a>语法说明</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><blockquote><p><code>#</code> 这是 <code>&lt;h1&gt;</code>一级标题</p><p><code>##</code> 这是 <code>&lt;h2&gt;</code> 二级标题</p><p> <code>###</code>这是 <code>&lt;h3&gt;</code> 三级标题</p><p><code>####</code> 这是 <code>&lt;h4&gt;</code> 四级标题</p><p><code>#####</code> 这是 <code>&lt;h5&gt;</code> 五级标题</p><p><code>######</code> 这是 <code>&lt;h6&gt;</code> 六级标题</p></blockquote><p>如果你想要给你的标题加<code>id</code>或者<code>class</code>，请在标题最后添加<code>{#id .class1 .class2}</code>。例如：</p><blockquote><p><code>#</code> 这个标题拥有 1 个 id {`#my_id}</p><p><code>#</code> 这个标题拥有 2 个 classes {.class1 .class2}</p></blockquote><blockquote><p>这是一个 MPE扩展特性。</p></blockquote><h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><blockquote><p><code>*</code>这会是 <em>斜体</em>  的文字<code>*</code></p><p><code>_</code>这会是  <em>斜体</em>  的文字<code>_</code></p><p><code>**</code>这会是 <strong>粗体</strong> 的文字<code>**</code> </p><p><code>__</code>这会是 <strong>粗体</strong> 的文字<code>__</code> </p><p><code>_</code><em>你也 <code>**</code><strong>组合</strong><code>** </code> 这些符号</em><code>_</code></p><p><code>~~</code><del>这个文字将会被横线删除</del><code>~~</code></p></blockquote><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><blockquote><p><code>-</code> Item 1</p><p><code>-</code> Item 2</p><p>​    <code>-</code> Item 2a</p><p>​    <code>-</code> Item 2b</p></blockquote><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><pre class=" language-markdown"><code class="language-markdown"> <span class="token list punctuation">1.</span>  Item 1 <span class="token list punctuation">2.</span>  Item 2 <span class="token list punctuation">3.</span>  Item 3<span class="token code keyword">    1.  Item 3a</span><span class="token code keyword">    1.  Item 3b</span></code></pre><h3 id="添加图片"><a href="#添加图片" class="headerlink" title="添加图片"></a>添加图片</h3><pre class=" language-markdown"><code class="language-markdown">！<span class="token url">[github logo](/ijmages/logo.png)</span>Foramt: <span class="token url">![Alt Text](url)</span></code></pre><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><pre class=" language-markdown"><code class="language-markdown">https://github.com - 自动生成！<span class="token url">[GitHub](https://github.com)</span></code></pre><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><pre class=" language-markdown"><code class="language-markdown">正如 Kanye West 所说：<span class="token blockquote punctuation">></span> We're living the future so<span class="token blockquote punctuation">></span> the present is our past.</code></pre><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><pre class=" language-markdown"><code class="language-markdown">如下，三个或者更多的<span class="token hr punctuation">---</span>连字符<span class="token hr punctuation">---</span>星号<span class="token hr punctuation">---</span>下划线</code></pre><h3 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h3><pre class=" language-markdown"><code class="language-markdown">我觉得你应该在这里使用<span class="token code keyword">`&lt;addr>`</span> 才对。</code></pre><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><pre class=" language-markdown"><code class="language-markdown">你可以在你的代码上面和下面添加 ``` 来表示代码块。</code></pre><h4 id="语法高亮"><a href="#语法高亮" class="headerlink" title="语法高亮"></a>语法高亮</h4><p>你可以给你的代码块添加任何一种语言的语法高亮</p><p>例如，给 ruby 代码添加语法高亮：</p><pre class=" language-markdown"><code class="language-markdown">​```rubyrequire 'redcarpet'markdown = Redcarpet.new("Hello World!")puts markdown.to_html​```</code></pre><p>会得到下面的效果：</p><pre class=" language-ruby"><code class="language-ruby"><span class="token keyword">require</span> <span class="token string">'redcarpet'</span> markdown <span class="token operator">=</span> <span class="token constant">Redcarpet</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span> puts markdown<span class="token punctuation">.</span>to_html</code></pre><h4 id="代码块class-MPE扩展的特性"><a href="#代码块class-MPE扩展的特性" class="headerlink" title="代码块class(MPE扩展的特性)"></a>代码块class(MPE扩展的特性)</h4><p>你可以给你的代码块设置 <code>class</code>。</p><p>例如，添加 <code>class1 class2</code> 到一个 代码块：</p><pre class=" language-markdown"><code class="language-markdown">​```javascript {.class1 .class}function add(x, y) {  return x + y}​```</code></pre><h4 id="代码行数"><a href="#代码行数" class="headerlink" title="代码行数"></a>代码行数</h4><p>如果你想要你的代码块显示代码行数，只要添加 <code>line-numbers</code> class 就可以了。</p><p>例如：</p><pre class=" language-markdown"><code class="language-markdown">​```javascript {.line-numbers}function add(x, y) {  return x + y}​```</code></pre><p>将会得到下面的显示效果：</p><p><img src="../../medias/images/3-1.png" alt="配图 3-1"></p><h4 id="高亮代码行数"><a href="#高亮代码行数" class="headerlink" title="高亮代码行数"></a>高亮代码行数</h4><p>你可以通过添加 <code>highlight</code> 属性的方式来高亮代码行数：</p><pre class=" language-markdown"><code class="language-markdown">​```javascript {highlight=10}​```​```javascript {highlight=10-20}​```​```javascript {highlight=[1-10,15,20-22]}​```</code></pre><h3 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h3><pre class=" language-markdown"><code class="language-markdown"><span class="token list punctuation">-</span> [x] @mentions, #refs, [links](), <span class="token bold"><span class="token punctuation">**</span>formatting<span class="token punctuation">**</span></span>, and <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>del</span><span class="token punctuation">></span></span>tags<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>del</span><span class="token punctuation">></span></span> supported<span class="token list punctuation">-</span> [x] list syntax required (any unordered or ordered list supported)<span class="token list punctuation">-</span> [x] this is a complete item<span class="token list punctuation">-</span> [ ] this is an incomplete item</code></pre><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><pre class=" language-markdown"><code class="language-markdown"><span class="token title important">First Header | Second Header<span class="token punctuation">------------</span></span> | -------------Content from cell 1 | Content from cell 2Content in the first column | Content in the second column</code></pre><h2 id="扩展的语法"><a href="#扩展的语法" class="headerlink" title="扩展的语法"></a>扩展的语法</h2><h3 id="表格-1"><a href="#表格-1" class="headerlink" title="表格"></a>表格</h3><blockquote><p>需要在插件设置中打开 <code>enableExtendedTableSyntax</code> 选项来使其工作。</p></blockquote><p><img src="../../medias/images/3-2.png" alt="配图 3-2"></p><h3 id="Emoji-amp-Font-Awesome"><a href="#Emoji-amp-Font-Awesome" class="headerlink" title="Emoji &amp; Font-Awesome"></a>Emoji &amp; Font-Awesome</h3><blockquote><p>只适用于 <code>markdown-it parser</code> 而不适用于 <code>pandoc parser</code>。<br>缺省下是启用的。你可以在插件设置里禁用此功能。</p></blockquote><pre><code>:smile::fa-car:</code></pre><h3 id="上标"><a href="#上标" class="headerlink" title="上标"></a>上标</h3><pre class=" language-markdown"><code class="language-markdown">30^th^</code></pre><h3 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h3><pre class=" language-markdown"><code class="language-markdown">H~2~O</code></pre><h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><pre class=" language-markdown"><code class="language-markdown">Content [^1]<span class="token url-reference url"><span class="token punctuation">[</span><span class="token variable">^1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> Hi!</span> This is a footnote</code></pre><h3 id="缩略"><a href="#缩略" class="headerlink" title="缩略"></a>缩略</h3><pre class=" language-markdown"><code class="language-markdown">_<span class="token url-reference url"><span class="token punctuation">[</span><span class="token variable">HTML</span><span class="token punctuation">]</span><span class="token punctuation">:</span> Hyper</span> Text Markup Language_<span class="token url-reference url"><span class="token punctuation">[</span><span class="token variable">W3C</span><span class="token punctuation">]</span><span class="token punctuation">:</span> World</span> Wide Web ConsortiumThe HTML specificationis maintained by the W3C.</code></pre><h3 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h3><pre class=" language-markdown"><code class="language-markdown">==marked==</code></pre><h3 id="CriticMarkup"><a href="#CriticMarkup" class="headerlink" title="CriticMarkup"></a>CriticMarkup</h3><p>CriticMarkup 缺省是禁用的，你可以通过插件设置来启动它。<br>有关 CriticMarkup 的更多信息，请查看 <a href="https://criticmarkup.com/users-guide.php">CriticMarkup 用户指南</a>.</p><p>这里有 5 种基本语法：</p><pre><code>添加 {++ ++}删除 {-- --}替换 {~~ ~&gt; ~~}注释 {&gt;&gt; &lt;&lt;}高亮 {== ==}{&gt;&gt; &lt;&lt;}</code></pre><blockquote><p>CriticMarkup 仅可用于 markdown-it parser，不与 pandoc parser 兼容。</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://guides.github.com/features/mastering-markdown/">Mastering Markdown</a></li><li><a href="https://daringfireball.net/projects/markdown/basics">Daring Fireball: Markdown Basics</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.1.1操作系统的基本概念</title>
      <link href="posts/2.html"/>
      <url>posts/2.html</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统的基本概念"><a href="#操作系统的基本概念" class="headerlink" title="操作系统的基本概念"></a>操作系统的基本概念</h1><h2 id="概念-定义"><a href="#概念-定义" class="headerlink" title="概念(定义)"></a>概念(定义)</h2><p><strong><em>操作系统（Operating System，OS）</em></strong> 是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调用计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的软件系统<br><img src="../../medias/images/1-1.png" alt="配图 1-1"></p><h2 id="功能和目标"><a href="#功能和目标" class="headerlink" title="功能和目标"></a>功能和目标</h2><h3 id="资源的管理者"><a href="#资源的管理者" class="headerlink" title="资源的管理者"></a>资源的管理者</h3><p>提供的功能</p><blockquote><ul><li>处理机管理</li><li>存储器管理</li><li>文件管理</li><li>设备管理</li></ul></blockquote><p>目标</p><blockquote><ul><li>安全、高效</li></ul></blockquote><p><img src="../../medias/images/1-2.png" alt="配图 1-2"></p><h3 id="向用户提供服务（作为用户和计算机硬件之间的接口）"><a href="#向用户提供服务（作为用户和计算机硬件之间的接口）" class="headerlink" title="向用户提供服务（作为用户和计算机硬件之间的接口）"></a>向用户提供服务（作为用户和计算机硬件之间的接口）</h3><ul><li><p>提供的功能（统称为“用户接口”）</p><ol><li>命令接口（允许用户直接使用）<br>联机命令接口（交互式命令接口）<br>用户说一句，系统做一句<br><img src="../../medias/images/1-3.png" alt="配图 1-3"><br>脱机命令接口（批处理命令接口）<br>用户说一堆，系统做一堆<br><img src="../../medias/images/1-4.png" alt="配图 1-4"></li><li>程序接口（允许用户通过程序间接使用）<br>由一组系统调用组成（程序接口=系统调用）<br>系统调用=系统调用命令=广义指令<br><img src="../../medias/images/1-5.png" alt="配图 1-4"></li><li>GUI（图形用户界面）</li></ol></li><li><p>目标<br>方便使用</p></li></ul><h3 id="对硬件机器的扩展"><a href="#对硬件机器的扩展" class="headerlink" title="对硬件机器的扩展"></a>对硬件机器的扩展</h3><ul><li>扩展能力<br><img src="../../medias/images/1-6.png" alt="配图 1-4"></li></ul>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown</title>
      <link href="posts/1.html"/>
      <url>posts/1.html</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h1><h1 id="我展示的是一级标题"><a href="#我展示的是一级标题" class="headerlink" title="我展示的是一级标题"></a>我展示的是一级标题</h1><h2 id="我展示的是二级标题"><a href="#我展示的是二级标题" class="headerlink" title="我展示的是二级标题"></a>我展示的是二级标题</h2><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p>Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。<br>比<br>如</p><h1 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h1><p><em>斜体文本</em><br><em>斜体文本</em><br><strong>粗体文本</strong><br><strong>粗体文本</strong><br><strong><em>粗斜体文本</em></strong><br><strong><em>粗斜体文本</em></strong></p><h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p><hr><hr><hr><hr><hr><h1 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h1><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下：<br>I can <del>‘t</del> do it</p><h1 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h1><p>下划线可以通过 HTML 的 &lt;u&gt; 标签来实现：</p><p><u>带下划线文本</u></p><h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><p>脚注是对文本的补充说明。</p><p>Markdown 脚注的格式如下:<br>[^要注明的文本]</p><p><a href="%E6%BC%86%E5%BD%B1%E5%BC%BA">^QYQ</a>你可以的，加油！</p><h1 id="Markdown-列表"><a href="#Markdown-列表" class="headerlink" title="Markdown 列表"></a>Markdown 列表</h1><p>Markdown 支持有序列表和无序列表。</p><p>无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容：</p><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><p>有序列表使用数字并加上 . 号来表示，如：</p><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol><p>列表嵌套<br>列表嵌套只需在子列表中的选项前面添加四个空格即可：</p><ol><li>第一项：<ul><li>第一项嵌套的第一个元素</li><li>第一项嵌套的第二个元素</li></ul></li><li>第二项：<ul><li>第二项嵌套的第一个元素</li><li>第二项嵌套的第二个元素</li></ul></li></ol><h1 id="Markdown-区块"><a href="#Markdown-区块" class="headerlink" title="Markdown 区块"></a>Markdown 区块</h1><p>Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号：</p><blockquote><p>区块引用<br>结果交给锦鲤，<br>你只管努力就行！</p></blockquote><p>另外区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推：</p><blockquote><p>最外层</p><blockquote><p>第一层嵌套</p><blockquote><p>第二层嵌套</p></blockquote></blockquote></blockquote><p>区块中使用列表<br>区块中使用列表实例如下：</p><blockquote><p>区块中使用列表</p><ol><li>第一项</li><li>第二项</li></ol><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></blockquote><p>列表中使用区块<br>如果要在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进。</p><p>列表中使用区块实例如下：</p><ul><li>第一项<blockquote><p>结果交给锦鲤，<br>你只管努力就行！</p></blockquote></li><li>第二项</li></ul><h1 id="Markdown-代码"><a href="#Markdown-代码" class="headerlink" title="Markdown 代码"></a>Markdown 代码</h1><p>如果是段落上的一个函数或片段的代码可以用反引号把它包起来（`），例如：</p><p><code>printf()</code> 函数</p><p>代码区块<br>代码区块使用 4 个空格或者一个制表符（Tab 键）。</p><p>实例如下：<br>    &lt;?php<br>    echo ‘luoluo’<br>    function test(){<br>        echo ‘test’;<br>    }<br>    &gt;</p><p>你也可以用 ``` 包裹一段代码，并指定一种语言（也可以不指定）：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">$</span><span class="token punctuation">(</span>document<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ready</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'RUNOOB'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h1 id="Markdown-链接"><a href="#Markdown-链接" class="headerlink" title="Markdown 链接"></a>Markdown 链接</h1><p>链接使用方法如下：</p><p><a href="%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80">链接名称</a></p><p>或者</p><p>&lt;链接地址&gt;<br>例如：</p><p>这是一个链接 <a href="https://www.runoob.com/">菜鸟教程</a></p><p>高级链接<br>我们可以通过变量来设置一个链接，变量赋值在文档末尾进行：</p><p>这个链接用 1 作为网址变量 <a href="http://www.google.com/">Google</a><br>这个链接用 runoob 作为网址变量 <a href="http://www.runoob.com/">Runoob</a><br>然后在文档的结尾为变量赋值（网址）</p><h1 id="Markdown-图片"><a href="#Markdown-图片" class="headerlink" title="Markdown 图片"></a>Markdown 图片</h1><p>  Markdown 图片语法格式如下：</p><p><img src="%E5%9B%BE%E7%89%87%E5%9C%B0%E5%9D%80" alt="alt 属性文本"></p><p><img src="%E5%9B%BE%E7%89%87%E5%9C%B0%E5%9D%80" alt="alt 属性文本" title="可选标题"><br>开头一个感叹号 !<br>接着一个方括号，里面放上图片的替代文字<br>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 属性的文字。<br>使用实例：</p><p><img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB 图标"></p><p><img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB 图标" title="RUNOOB"></p><p>当然，你也可以像网址那样对图片网址使用变量:</p><p>这个链接用 1 作为网址变量 <a href="http://www.google.com/">RUNOOB</a>.<br>然后在文档的结尾为变量赋值（网址）</p><h1 id="Markdown-表格"><a href="#Markdown-表格" class="headerlink" title="Markdown 表格"></a>Markdown 表格</h1><p>Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。</p><p>语法格式如下：</p><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table><p>对齐方式</p><p>我们可以设置表格的对齐方式：</p><p>-: 设置内容和标题栏居右对齐。<br>:- 设置内容和标题栏居左对齐。<br>:-: 设置内容和标题栏居中对齐。<br>实例如下：</p><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table><h1 id="Markdown-高级技巧"><a href="#Markdown-高级技巧" class="headerlink" title="Markdown 高级技巧"></a>Markdown 高级技巧</h1><p>支持的 HTML 元素<br>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。</p><p>目前支持的 HTML 元素有：<kbd> <b> <i> <em> <sup> <sub> <br>等 ，如：</sub></sup></em></i></b></kbd></p><b><i><em><p>使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑</p><p>转义<br>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：</p><p><strong>文本加粗</strong><br>** 正常显示星号 **</p><p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p><p>\   反斜线<br>`   反引号<br>*   星号<br>_   下划线<br>{}  花括号<br>[]  方括号<br>()  小括号<br>#   井字号<br>+   加号<br>-   减号<br>.   英文句点<br>!   感叹号</p><p>公式<br>当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：</p><p>$$<br>\mathbf{V}_1 \times \mathbf{V}_2 =  \begin{vmatrix}<br>\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \<br>\frac{\partial X}{\partial u} &amp;  \frac{\partial Y}{\partial u} &amp; 0 \<br>\frac{\partial X}{\partial v} &amp;  \frac{\partial Y}{\partial v} &amp; 0 \<br>\end{vmatrix}<br>${$tep1}{\style{visibility:hidden}{(x+1)(x+1)}}<br>$$</p></em></i></b>]]></content>
      
      
      
        <tags>
            
            <tag> md </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="posts/16107.html"/>
      <url>posts/16107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
